[
  {
    "path": "posts/scientificwritingtips/",
    "title": "Scientific Writing Tips",
    "description": "Find here some guidelines how to write and structure a scientific introduction, a scientific discussion or prepare a response letter for your revisions. You will find three pdf documents, one for each section.",
    "author": [
      {
        "name": "Aimara Planillo",
        "url": {}
      }
    ],
    "date": "2023-10-11",
    "categories": [
      "tutorial",
      "writing",
      "workflow"
    ],
    "contents": "\r\nIntroduction\r\nlink\r\nDiscussion\r\nlink\r\nResponse Letter\r\nlink\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/clippingmaskberlin/",
    "title": "Clipping a Raster to a Specific Area",
    "description": "Learn how to use a clipping mask to extract a portion of a raster, based on a template extent. In this example we show you how to clip a raster map to the extent and borders of Berlin boundaries.",
    "author": [
      {
        "name": "Moritz Wenzler-Meya",
        "url": {}
      }
    ],
    "date": "2023-06-26",
    "categories": [
      "tutorial",
      "spatial",
      "Berlin"
    ],
    "contents": "\r\n\r\nContents\r\nExample PopDynCloud\r\nExample geoboundaries\r\n\r\nSometimes you will get a dataset that is larger than your study area and you want to clip it to your specific extent or boundaries. There are two ways to do that:\r\nthe crop function of the {terra} package: this will crop the dataset to the extent of the cropping mask\r\nthe mask function of the {terra} package: this will crop the dataset to the extent of the cropping mask and set everything outside of the mask boundaries to NA (or to a custom set value)\r\nIn this tutorial only the mask function is covered because the crop function is straightforward to use. The mask function gives the opportunity to only get the raster cells that are covered by another raster or spatial object.\r\nHere are two examples showing how to use data from the PopDynCloud and one with data from the geoboundaries website/package:\r\n\r\n\r\nlibrary(d6geodata)\r\nlibrary(sf)\r\nlibrary(terra)\r\nlibrary(dplyr)\r\n\r\n\r\nExample PopDynCloud\r\nIf you have access to the PopDynCloud you can use the districts_berlin_layer like this:\r\n\r\n\r\nberlin_mask <- get_geodata(data_name =  \"districs_berlin_2022_poly_03035_gpkg\",\r\n                           path_to_cloud = \"E:/PopDynCloud\") # get_geodata function from the d6geodata package\r\n\r\nReading layer `districs_berlin_2022_poly_03035' from data source \r\n  `E:\\PopDynCloud\\GeoData\\data-raw\\berlin\\districs_berlin_2022_poly_03035_gpkg\\districs_berlin_2022_poly_03035.gpkg' \r\n  using driver `GPKG'\r\nSimple feature collection with 97 features and 6 fields\r\nGeometry type: MULTIPOLYGON\r\nDimension:     XY\r\nBounding box:  xmin: 4531043 ymin: 3253864 xmax: 4576654 ymax: 3290795\r\nProjected CRS: ETRS89-extended / LAEA Europe\r\n\r\nrast_example <- get_geodata(data_name =  \"tree-cover-density_berlin_2018_10m_03035_tif\",\r\n                           path_to_cloud = \"E:/PopDynCloud\")\r\n\r\n\r\nplot_quantitative_map(tif = rast_example) # plot not masked layer\r\n\r\n\r\nrast_example_masked <- mask(rast_example, # input raster \r\n                            berlin_mask) # mask to be clipped on \r\n\r\nplot_quantitative_map(tif = rast_example_masked) # plot masked layer\r\n\r\n\r\n\r\nExample geoboundaries\r\nIf not, you can use the data from the geoboundaries website or using the rgeoboundaries package from github:\r\n\r\n\r\nremotes::install_github(\"dickoa/rgeoboundaries\")\r\n\r\n\r\n\r\n\r\nlibrary(rgeoboundaries)\r\nrgeob_mask_berlin <- rgeoboundaries::gb_adm2(\"Germany\") %>% # set Country name(s)\r\n  filter(shapeName %in% \"Berlin\") %>% # filter for Berlin\r\n  st_transform(3035) # reproject to 3035 (or desired crs) \r\n\r\nrast_example_rgeob_masked <- mask(rast_example, # input raster \r\n                                  rgeob_mask_berlin) # mask to be clipped on\r\n\r\nplot_quantitative_map(tif = rast_example_rgeob_masked) # plot with function from d6geodata package\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/clippingmaskberlin/clippingmaskberlin_files/figure-html5/example-1.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/howtopost/",
    "title": "How to Make a Blogpost: a Brief Introduction",
    "description": "Learn how to contribute to the wiki section of the Ecological Dynamics Department webpage. If you think you have an important information, script, package or just a piece of code that might be interesting for your colleagues, consider to turn it into a blogpost for our webpage.",
    "author": [
      {
        "name": "Moritz Wenzler-Meya",
        "url": {}
      },
      {
        "name": "C√©dric Scherer",
        "url": {}
      }
    ],
    "date": "2023-06-26",
    "categories": [
      "tutorial",
      "workflow"
    ],
    "contents": "\r\n\r\nContents\r\nCreate a Blogpost\r\nStep 0 ‚Äî Install the {d6} Package\r\nStep 1 ‚Äî Use the D6 Blogpost Template\r\nStep 2 ‚Äî Fill the YAML Header of the Script\r\nStep 3 ‚Äî Add the Content\r\nStep 4 ‚Äî Render the Blogpost\r\nStep 5 ‚Äî Review Process\r\nStep 6 ‚Äî Published!\r\n\r\nGeneral Tips for Posting\r\n\r\nYou have a nice piece of code? You have developed a cool package? You have something to share within (or even outside) our department?\r\nYou can share it with a blogpost on our EcoDynIZW Website by following these simple steps!\r\nCreate a Blogpost\r\nStep 0 ‚Äî Install the {d6} Package\r\nIf not yet installed, install the {d6} package. It provides several functions for our department along with Rmarkdown templates, including the D6 blogpost template.\r\n\r\n\r\n# install.packages(remotes)\r\nremotes::install_github(\"EcoDynIZW/d6\")\r\n\r\n\r\nStep 1 ‚Äî Use the D6 Blogpost Template\r\nIn RStudio, navigate to File > New File... > R Markdown... .\r\nIn the From Template section, choose the D6 Blogpost Template from the list.\r\n\r\n\r\nIf the template is not listed, please make sure that the latest version of {d6} is installed.\r\nStep 2 ‚Äî Fill the YAML Header of the Script\r\nFill in a proper name, please use uppercase for the name.\r\nWrite a short description. Please have in mind that this description will appear on the blogpost listing page as well as in the post. Usually, we start these descriptions with ‚ÄúLearn how to learn x to do y.‚Äù.\r\nAdd some categories that relate to your article. For examples, browse through other posts featured in the wiki section of our web page.\r\nEnter your name and the date of the post in the given format.\r\nStep 3 ‚Äî Add the Content\r\nDescribe briefly what you will show us and describe each chunk separately.\r\nLeave a line of space between text and chunk for separating text and chunk output.\r\nPlease use the chunk options to name chunks, hide them or ignore them in the knitting process. This will help later to find possible errors.\r\nStep 4 ‚Äî Render the Blogpost\r\nKnit the post and check if the knitted document looks as desired.\r\nStep 5 ‚Äî Review Process\r\nSend the Rmd file to the data manager for review.\r\nWait for feedback by the data manager. If changes are requested, update the article accordingly and send the corrected script.\r\nStep 6 ‚Äî Published!\r\nThe data manager will publish your post as soon as possible on the website.\r\nGeneral Tips for Posting\r\nPlease use the spell check before knitting and pushing the post.\r\nPlease check if the code is running (in a reasonable time) as we have to rebuild the page from time to time.\r\nUse styling like `plot()` for function names in the text and `{pckg}` package names.\r\nPick examples that are simple enough in terms of file size and performance so that they can be easily reproduced within the script.\r\nMake sure that your code can be run by anybody reading the post. If you need data inputs, generate made-up data examples, use data sets from packages, or link to the data source (make sure it is publicly available as readers are not necessarily part of the department!)\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/ggplot-workflow/",
    "title": "ggplot2 Workflow Tips",
    "description": "Learn how to efficiently use the powerful graphics library {ggplot2} by avoiding repeated code and manual adjustments. You will learn how to define your themes globally and how to use the {patchwork} package to create multi-panel plots with automated numbering and combined legends.",
    "author": [
      {
        "name": "Cedric Scherer",
        "url": "https://cedricscherer.com"
      }
    ],
    "date": "2023-06-22",
    "categories": [
      "rstats",
      "ggplot2",
      "workflow",
      "tutorial"
    ],
    "contents": "\r\n\r\nContents\r\nSetup\r\nTheming\r\nSet Themes Globally\r\nAdjust Theme Base Settings\r\nUpdate Theme Elements\r\nCustom Local Modifications\r\nSummary\r\n\r\nMulti-Panel Figures\r\nAdjust Layout\r\nAdd White Space\r\nNested Layouts\r\nMerge Legends\r\nAutomate Plot Tags\r\nInset Plots\r\nSummary\r\n\r\n\r\nSetup\r\nLet‚Äôs load the {ggplot2} library and create two basic ggplots, stored as g1 (scatter plot) and g2 (box-and-whisker plot) that can be used later.\r\n\r\n\r\nlibrary(ggplot2)\r\n\r\n\r\n\r\n\r\ng1 <- ggplot(mpg, aes(x = displ, y = hwy)) +\r\n  geom_point(aes(color = class))\r\n\r\ng1\r\n\r\n\r\ng2 <- ggplot(mpg, aes(x = class, y = hwy)) +\r\n  geom_boxplot()\r\n\r\ng2\r\n\r\n\r\n\r\n\r\n\r\nTheming\r\nThe resulting plots use the default gray theme: theme_gray() or theme_grey().\r\nWe can change the default theme by adding a complete theme, starting with theme_*(), and/or customizing single elements of the default theme via theme():\r\n\r\n\r\ng1 + \r\n  ## apply light complete theme\r\n  theme_light() + \r\n  ## remove minor grid + modify typeface\r\n  theme(panel.grid.minor = element_blank(),\r\n        text = element_text(family = \"PT Sans\"))\r\n\r\n\r\ng2 + \r\n  theme_light() + \r\n  theme(panel.grid.minor = element_blank(), \r\n        text = element_text(family = \"PT Sans\"))\r\n\r\n\r\n\r\n\r\n\r\nThis procedure involves a lot of copy-and-paste‚Äôing, which makes it a tedious procedure especially in case you decide to make some general styling changes at a later point. It is also prone to mistakes as you might forget to set specific adjustments for single plots.\r\nSet Themes Globally\r\nInstead of repeating the same code to change the appearance of your plots, it is more efficient and beneficial to overwrite the default global theme:\r\n\r\n\r\ntheme_set(theme_light())\r\n\r\n\r\nAfter setting the new theme, all plots created within the same environment are styled accordingly:\r\n\r\n\r\ng1\r\n\r\n\r\ng2\r\n\r\n\r\n\r\n\r\n\r\nAdjust Theme Base Settings\r\nComplete themes allow for some general modifications, no matter if added locally to your plot or if set globally. The setting include the typeface used for all text elements (base_family), the general base size (base_size) as well as dedicated relative sizes for line elements (base_line_size) and rect elements (base_rect_size).\r\n\r\n\r\ng1 + \r\n  theme_light(\r\n    base_family = \"PT Serif\", ## default: depends on OS\r\n    base_size = 18,           ## default: 11\r\n    base_line_size = 3,       ## default: base_size/22 -> 0.5\r\n    base_rect_size = 10       ## default: base_size/22 -> 0.5\r\n  )\r\n\r\n\r\n\r\nKnowing of this feature, we can already adjust the general size (which tends to be too small by default) as well as the typeface of our custom global theme:\r\n\r\n\r\ntheme_set(theme_light(base_size = 15, base_family = \"PT Sans\")) \r\n\r\n\r\n‚Ä¶ which is then used for all following plots:\r\n\r\n\r\ng1\r\n\r\n\r\ng2\r\n\r\n\r\n\r\n\r\n\r\nUpdate Theme Elements\r\nComplete themes are great but in most circumstances we likely want to adjust a few things. Usually, you do that by adding the theme() function to your ggplot (as shown in the beginning). However, similarly to theme_set() we can apply the modifications globally:\r\n\r\n\r\ntheme_update(\r\n  panel.grid.minor = element_blank(),\r\n  axis.title = element_text(face = \"bold\"),\r\n  legend.title = element_text(face = \"bold\")\r\n)\r\n\r\n\r\n\r\n\r\ng1\r\n\r\n\r\ng2\r\n\r\n\r\n\r\n\r\n\r\nCustom Local Modifications\r\nOf course, you can still either overwrite the global theme as before or modify specific elements for a single plot if needed:\r\n\r\n\r\ng1 + \r\n  ## new complete theme\r\n  theme_classic(base_family = \"PT Serif\", base_size = 15) + \r\n  ## add grid lines\r\n  theme(panel.grid.major = element_line(color = \"grey90\"))\r\n\r\n\r\ng2 + \r\n  ## remove vertical grid lines + overwrite axis title styling\r\n  theme(panel.grid.major.x = element_blank(), \r\n           axis.title = element_text(color = \"red\", face = \"italic\")) \r\n\r\n\r\n\r\n\r\n\r\nSummary\r\nSetting and updating ggplot themes globally is efficient and avoids potential mistakes.\r\nAs a workflow routine, add a chunk that loads {ggplot2} and afterwards sets and updates your theme at the beginning of a script rather than adding the same code to each plot individually.\r\nMulti-Panel Figures\r\nWe often use multi-panel visualizations, i.e.¬†several plots layed out in a single graphic. Instead of combining single figures manually, we make use of a coding-first approach.\r\nThere are many packages to combine ggplots such as {gridExtra}, {cowplot}, and {ggarrange}. The most recent, and IMHO the best in terms of functionality and simplicity, is the {patchwok} package by Thomas Lin Pedersen. For simple multi-panel graphics, mathematical operators can be used ‚Äì easy to use and remember.\r\n\r\n\r\nlibrary(patchwork)\r\n\r\n\r\n\r\n\r\ng1 + g2\r\n\r\n\r\n\r\n\r\n\r\ng1 / g2\r\n\r\n\r\n\r\nAdjust Layout\r\nBy default, both plots take the same space. In case you want to adjust how the plots are laid out, use plot_layout() in combination with either widths or heights. These arguments take a vector with the relative width or height for each plot, respectively.\r\n\r\n\r\ng1 + g2 + \r\n  plot_layout(widths = c(.5, 1))\r\n\r\n\r\n\r\nAdd White Space\r\n{patchwok} comes with a placeholder to add empty space between plots. Once can add a plot_spacer() similar to a regular plot:\r\n\r\n\r\ng1 + plot_spacer() + g2 + \r\n  plot_layout(widths = c(.5, .1, 1))\r\n\r\n\r\n\r\nNested Layouts\r\nAlso more complex layouts can be created:\r\n\r\n\r\n\r\n\r\n\r\n(g1 + g3 + g4) / (g2 + g5)\r\n\r\n\r\n\r\nCode to create g3, g4, and g5\r\n\r\n\r\ng3 <- ggplot(mpg, aes(x = cyl, y = hwy)) +\r\n  geom_point(aes(color = class))\r\n\r\ng4 <- ggplot(mpg, aes(x = cty, y = hwy)) +\r\n  geom_point(aes(color = class))\r\n\r\ng5 <- ggplot(mpg, aes(x = class, y = hwy)) +\r\n  stat_summary(fun.data = \"mean_sdl\", fun.args = list(mult = 1))\r\n\r\n\r\n\r\n\r\n\r\nAlternatively, you can also create a design layout to have full control:\r\n\r\n\r\nlayout <- \r\n  \"\r\n  ABBCCC#\r\n  DDDD#EE\r\n  \"\r\n\r\ng1 + g3 + g4 + g2 + g5 + \r\n  plot_layout(design = layout)\r\n\r\n\r\n\r\nThe letters refer to the single plots (in the order you combine them later) and a hash # indicates empty space, similar to plot_spacer().\r\nMerge Legends\r\nDisplaying the legend three times makes no sense. {patchwork} offers the utility to ‚Äúcollect your guides‚Äù inside the plot_layout() function:\r\n\r\n\r\n(g1 + g3 + g4) / (g2 + g5) + \r\n  plot_layout(guides = \"collect\")\r\n\r\n\r\n\r\nNow we may want to move it to the top so it is shown next to the relevant colored scatter plots, not in the middle. We can adjust the theme for all plots inside another {patchwork} function called plot_annotation()‚Äîor by updating your global theme üòâ\r\n\r\n\r\n((g1 + g3 + g4) / (g2 + g5)) + \r\n  plot_layout(guides = \"collect\") +\r\n  plot_annotation(theme = theme(legend.justification = \"top\"))\r\n\r\n\r\n\r\nAutomate Plot Tags\r\nWhen preparing such multi-panel figures for publications, we usually want to add tags to be able to refer to subplots in the figure caption or main text. Again, we can do this inside R instead of adding them afterwards by hand (which either takes very long or results in irregularly aligned labels).\r\n\r\n\r\n((g1 + g3 + g4) / (g2 + g5)) + \r\n  plot_layout(guides = \"collect\") +\r\n  plot_annotation(tag_levels = \"A\", \r\n                  theme = theme(legend.justification = \"top\"))\r\n\r\n\r\n\r\n{patchwork} understands a range of numbering formats such as a for lowercase letters, 1 for numbers, or i and I for lowercase and uppercase Roman numerals, respectively. Furthermore we can style the tag by defining a pre- and/or suffix:\r\n\r\n\r\n((g1 + g3 + g4) / (g2 + g5)) + \r\n  plot_layout(guides = \"collect\") +\r\n  plot_annotation(tag_levels = \"i\", tag_prefix = \"(\", tag_suffix = \")\",\r\n                  theme = theme(legend.justification = \"top\"))\r\n\r\n\r\n\r\nInset Plots\r\nSimilar to other arrangement packages, we can use {patchwork} also to add inset plots. Inside the inside_element() function, we specify the plot to draw and then the outer bounds (left, bottom, right top).\r\n\r\n\r\ng4 + inset_element(g1 + guides(color = \"none\"), .5, 0, 1, .5)\r\n\r\n\r\n\r\nBy default, the inset plot is aligned with the panel of the main plot. If you want to modify the behavior, overwrite the default input of align_to.\r\n\r\n\r\ng4 + inset_element(g1 + guides(color = \"none\"), .5, 0, 1, .5, align_to = \"plot\")\r\ng4 + inset_element(g1 + guides(color = \"none\"), .5, 0, 1, .5, align_to = \"full\")\r\n\r\n\r\n\r\n\r\n\r\nSummary\r\n{patchwork} offers some great functionality to create basic and pretty complex layouts, add inset plots, merge repeated legends, and automate tag numbering. This makes it a powerful tool as you do not need to adjust tag labels, legends, and more for the individual ggplot.\r\n\r\n\r\n\r\n",
    "preview": "https://raw.githubusercontent.com/EcoDynIZW/EcoDynIZW.github.io/main/img/wiki/preview-ggplot-workflow.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/netlogoturtlespatialprojection/",
    "title": "Netlogo Turtle Spatial Projection",
    "description": "Learn how to transform the relative coordinates of the individuals from Netlogo into coordinates from real maps. This code is especially designed for spatially explicit netlogo models that were set to store the individual coordinates (xcor, ycor) in the output for the turtle data.",
    "author": [
      {
        "name": "Aimara Planillo",
        "url": {}
      }
    ],
    "date": "2023-06-15",
    "categories": [
      "NetLogo",
      "spatial",
      "tutorial"
    ],
    "contents": "\r\n\r\nContents\r\nHow to project Netlogo Turtle coordinates into a real map\r\n0. Load libraries\r\n1. Create data\r\n2. Get reference coordinates\r\n3. Transform turtle coordinates into map coordinates\r\n4. Quick plot with tmap\r\n5. Plot with ggplot2\r\n\r\n\r\nHow to project Netlogo Turtle coordinates into a real map\r\nWhen using spatial data in Netlogo, the coordinates of a raster get transformed to relative coordinates. This means, the cell in the bottom left gets coordinate (1,1), the one on top of it is (1,2), and so on.\r\nAfter running a model, usually we want to reproject the output back to the spatial data coordinates used, either for post-simulation analyses or for plotting.\r\nThis code shows how to project the turtles‚Äô coordinates back into a map, when a raster was\r\nused to create the Netlogo landscape.\r\nFor this we need:\r\n- The raster used as netlogo input\r\n- The turtle coordinates in the output\r\n0. Load libraries\r\n\r\n\r\nlibrary(terra)\r\nlibrary(dplyr)\r\nlibrary(sf)\r\nlibrary(tmap)\r\nlibrary(ggplot2)\r\nlibrary(ggspatial)\r\n\r\n\r\n1. Create data\r\nIn this example we create a raster and some turtle data to use.\r\nWith real data, you will load your raster here and make sure it has a PROJECTED coordinate system.\r\nTurtle data will have different formats depending how it was created, the basic data we need for this is the identity of the turtle and the coordinates.\r\n\r\n\r\n## Create raster with 100 cells for the example\r\nmyraster <- rast(nrows = 100, ncols = 100, \r\n                 xmin = 4541100, xmax = 4542100, \r\n                 ymin = 3265800, ymax = 3266800)\r\n## give random values to the raster\r\nmyraster <- init(myraster, sample(1:1000))\r\n\r\n## assign projection\r\ncrs(myraster) <- \"epsg:3035\"\r\nplot(myraster)\r\n\r\n\r\n## turtle data - example data\r\nwho <- seq(1,10)\r\nxcoord <- sample(1:100, 10) # create random integers for x coordinate\r\nycoord <- sample(1:100, 10) # create random integers for y coordinate\r\n\r\nturtle_variables <- cbind.data.frame(who, xcoord, ycoord)\r\nhead(turtle_variables)\r\n\r\n  who xcoord ycoord\r\n1   1      8     23\r\n2   2     51     97\r\n3   3     87     74\r\n4   4     11     24\r\n5   5     69     26\r\n6   6     68     81\r\n\r\nNow that we have our data, let‚Äôs extract the map coordinates as reference and transform the turtle ones. This process will work with any PROJECTED coordinate system.\r\n2. Get reference coordinates\r\nWe need the bottom left corner of the map as a reference point and the resolution of the map\r\n\r\n\r\n# we are going to trasnform the cell relative numbering to real coordinates, starting left down as this is where netlogo starts numbering the cells\r\nstart_left <- xmin(myraster)\r\nstart_down <- ymin(myraster)\r\nmy_res <- res(myraster)[1]\r\n\r\n\r\n3. Transform turtle coordinates into map coordinates\r\nNow we use the reference point to transform our coordinates into the projected coordinates and the resolution to correct for the size of the cells\r\n\r\n\r\nturtle_spatial <- turtle_variables %>% \r\n  mutate(spatial_xcoord = start_left + ((xcoord * my_res) + my_res/2), #divided by 2 to locate in the center of the cell\r\n         spatial_ycoord = start_down + ((ycoord * my_res) + my_res/2))\r\n\r\n\r\n## make spatial points\r\nturtle_sf <- st_as_sf(turtle_spatial, \r\n                      coords = c(\"spatial_xcoord\", \"spatial_ycoord\"), \r\n                      crs = crs(myraster))\r\n\r\n\r\n4. Quick plot with tmap\r\n\r\n\r\n\r\n5. Plot with ggplot2\r\n\r\n        x       y  hs\r\n1 4541105 3266795 902\r\n2 4541115 3266795 698\r\n3 4541125 3266795 500\r\n4 4541135 3266795 492\r\n5 4541145 3266795 405\r\n6 4541155 3266795 151\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/r-spatial-data/",
    "title": "Spatial Data Sources in R",
    "description": "Learn how to use a suite of R packages to download various spatial data sources. This guide illustrates how to download data of countries, physical objects, and cultural properties as vector or raster objects that can be assessed from within R.",
    "author": [
      {
        "name": "Cedric Scherer",
        "url": "https://cedricscherer.com"
      }
    ],
    "date": "2023-05-25",
    "categories": [
      "tutorial",
      "rstats",
      "workflow",
      "spatial",
      "data sources"
    ],
    "contents": "\r\n\r\nContents\r\nPreparation\r\n{rnaturalearth}\r\nCountry Data\r\nPhysical Data Sources\r\nCultural Data Sources\r\nRelief Data\r\n\r\n{rgeoboundaries}\r\n{osmdata}\r\n{elevatr}\r\n\r\nPreparation\r\nTo visualize the data sets, we use the {ggplot2}\r\npackage. We will also use the {sf} and the\r\n{terra} packages to work and plot spatial data‚Äìvector and\r\nraster, respectively‚Äìin R. Make sure all packages are installed when\r\nrunning the code snippets.\r\n\r\n\r\n# install.packages(\"ggplot2\")\r\n# install.packages(\"sf\")\r\n# install.packages(\"terra\")\r\n\r\nlibrary(ggplot2)\r\n\r\n### set \"empty\" theme with centered titles for ggplot output\r\ntheme_set(theme_void())\r\ntheme_update(plot.title = element_text(face = \"bold\", hjust = .5))\r\n\r\n\r\n\r\n\r\n{rnaturalearth}\r\nNaturalEarth is a\r\npublic domain map data set that features vector and raster data of\r\nphysical and cultural properties. It is available at 1:10m, 1:50m, and\r\n1:110 million scales.\r\n{rnaturalearth}\r\nis an R package to hold and facilitate interaction with NaturalEarth map\r\ndata via dedicated ne_* functions. After loading the\r\npackage, you can for example quickly access shapefiles of all\r\ncountries‚Äìthe resulting spatial object contains vector data that is\r\nalready projected and can be stored as either sp or\r\nsf format:\r\n\r\n\r\n## install development version of {rnaturalearth} as currently the \r\n## download doesn't work in the CRAN package version\r\n# install.packages(\"remotes\")\r\n# remotes::install_github(\"ropensci/rnaturalearth\")\r\n\r\n## for high resolution data, also install {rnaturalearthhires}\r\n# remotes::install_github(\"ropensci/rnaturalearthhires\")\r\n\r\nlibrary(rnaturalearth)\r\n\r\n## store as sp object (SpatialPolygonsDataFrame)\r\nworld <- ne_countries() ## `returnclass = \"sp\"` by default\r\nclass(world)\r\n\r\n\r\n[1] \"SpatialPolygonsDataFrame\"\r\nattr(,\"package\")\r\n[1] \"sp\"\r\n\r\n## store as sf object (simple features)\r\nworld <- ne_countries(returnclass = \"sf\")\r\nclass(world)\r\n\r\n\r\n[1] \"sf\"         \"data.frame\"\r\n\r\nsf::st_crs(world)[1]\r\n\r\n\r\n$input\r\n[1] \"+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0\"\r\n\r\nCountry Data\r\nThis country data set (which is actually not downloaded but stored\r\nlocally by installing the package) already contains several useful\r\nvariables, mostly referring to different naming conventions (helpful\r\nwhen joining with other data sets), to identify continents and regions,\r\nand also some information on population size, GDP, and economy:\r\n\r\n\r\nnames(world)\r\n\r\n\r\n [1] \"featurecla\" \"scalerank\"  \"labelrank\"  \"sovereignt\" \"sov_a3\"    \r\n [6] \"adm0_dif\"   \"level\"      \"type\"       \"admin\"      \"adm0_a3\"   \r\n[11] \"geou_dif\"   \"geounit\"    \"gu_a3\"      \"su_dif\"     \"subunit\"   \r\n[16] \"su_a3\"      \"brk_diff\"   \"name\"       \"name_long\"  \"brk_a3\"    \r\n[21] \"brk_name\"   \"brk_group\"  \"abbrev\"     \"postal\"     \"formal_en\" \r\n[26] \"formal_fr\"  \"name_ciawf\" \"note_adm0\"  \"note_brk\"   \"name_sort\" \r\n[31] \"name_alt\"   \"mapcolor7\"  \"mapcolor8\"  \"mapcolor9\"  \"mapcolor13\"\r\n[36] \"pop_est\"    \"pop_rank\"   \"gdp_md_est\" \"pop_year\"   \"lastcensus\"\r\n[41] \"gdp_year\"   \"economy\"    \"income_grp\" \"wikipedia\"  \"fips_10_\"  \r\n[46] \"iso_a2\"     \"iso_a3\"     \"iso_a3_eh\"  \"iso_n3\"     \"un_a3\"     \r\n[51] \"wb_a2\"      \"wb_a3\"      \"woe_id\"     \"woe_id_eh\"  \"woe_note\"  \r\n[56] \"adm0_a3_is\" \"adm0_a3_us\" \"adm0_a3_un\" \"adm0_a3_wb\" \"continent\" \r\n[61] \"region_un\"  \"subregion\"  \"region_wb\"  \"name_len\"   \"long_len\"  \r\n[66] \"abbrev_len\" \"tiny\"       \"homepart\"   \"min_zoom\"   \"min_label\" \r\n[71] \"max_label\"  \"ne_id\"      \"wikidataid\" \"name_ar\"    \"name_bn\"   \r\n[76] \"name_de\"    \"name_en\"    \"name_es\"    \"name_fr\"    \"name_el\"   \r\n[81] \"name_hi\"    \"name_hu\"    \"name_id\"    \"name_it\"    \"name_ja\"   \r\n[86] \"name_ko\"    \"name_nl\"    \"name_pl\"    \"name_pt\"    \"name_ru\"   \r\n[91] \"name_sv\"    \"name_tr\"    \"name_vi\"    \"name_zh\"    \"geometry\"  \r\n\r\nWe can quickly plot it:\r\n\r\n\r\nggplot(world) + \r\n  geom_sf(aes(fill = economy)) + \r\n  coord_sf(crs = \"+proj=eqearth\")\r\n\r\n\r\n\r\n\r\nNOTE: Unfortunately, NaturalEarth is using weird\r\nde-facto and on-the-ground rules to define country\r\nborders which do not follow the borders the UN and most countries agree\r\non. For correct and official borders, please use the\r\n{rgeoboundaries} package (see below).\r\nPhysical Data Sources\r\nYou can specify the scale, category, and type you want as in the\r\nexamples below.\r\n\r\n\r\nglacier_small <- ne_download(type = \"glaciated_areas\", category = \"physical\", \r\n                             scale = \"small\", returnclass = \"sf\")\r\n\r\nglacier_large <- ne_download(type = \"glaciated_areas\", category = \"physical\", \r\n                             scale = \"large\", returnclass = \"sf\")\r\n\r\n\r\n\r\nNow we can compare the impact of different scales specified‚Äìthere is\r\na notable difference in detail here (and also in size of the object with\r\n11 versus 1886 observations).\r\n\r\n\r\nggplot() + \r\n  geom_sf(data = world, color = \"grey85\", fill = \"grey85\") +\r\n  geom_sf(data = glacier_small, color = \"grey40\", fill = \"grey40\") + \r\n  coord_sf(crs = \"+proj=eqearth\")\r\n\r\nggplot() +\r\n  geom_sf(data = world, color = \"grey85\", fill = \"grey85\") +\r\n  geom_sf(data = glacier_large, color = \"grey40\", fill = \"grey40\") +\r\n  coord_sf(crs = \"+proj=eqearth\")\r\n\r\n\r\n\r\n\r\n\r\nlibrary(patchwork)\r\n\r\nsmall <- ggplot() + \r\n  geom_sf(data = world, color = \"grey85\", fill = \"grey85\", lwd = .05) +\r\n  geom_sf(data = glacier_small, color = \"grey40\", fill = \"grey40\") + \r\n  coord_sf(crs = \"+proj=eqearth\") +\r\n  labs(title = 'scale = \"small\"')\r\n\r\nlarge <- ggplot() +\r\n  geom_sf(data = world, color = \"grey85\", fill = \"grey85\", lwd = .05) +\r\n  geom_sf(data = glacier_large, color = \"grey40\", fill = \"grey40\") +\r\n  coord_sf(crs = \"+proj=eqearth\") + \r\n  labs(title = 'scale = \"large\"')\r\n\r\nsmall + large * theme(plot.margin = margin(0, -20, 0, -20))\r\n\r\n\r\n\r\n\r\nCultural Data Sources\r\nNaturalEarth also provides several cultural data sets, such as\r\nairports, roads, disputed areas. Let‚Äôs have a look at the urban areas\r\nacross the world:\r\n\r\n\r\nurban <- ne_download(type = \"urban_areas\", category = \"cultural\", \r\n                     scale = \"medium\", returnclass = \"sf\")\r\n\r\nggplot() + \r\n  geom_sf(data = world, color = \"grey90\", fill = \"grey90\") +\r\n  geom_sf(data = urban, color = \"firebrick\", fill = \"firebrick\") + \r\n  coord_sf(crs = \"+proj=eqearth\")\r\n\r\n\r\n\r\n\r\nRelief Data\r\nThe physical and cultural data sets showcased above are all vector\r\ndata. NaturalEarth also provides raster data, namely gridded relief\r\ndata:\r\n\r\n\r\nrelief <- ne_download(type = \"MSR_50M\", category = \"raster\",\r\n                      scale = 50, returnclass = \"sf\")\r\n\r\nterra::plot(relief)\r\n\r\n\r\n\r\n\r\n\r\n{rgeoboundaries}\r\nThe {rgeoboundaries}\r\npackage uses the Global Database of Political Administrative\r\nBoundaries that provide generally accepted political borders. The data\r\nare licensed openly.\r\n\r\n\r\n## install package from GitHub as it is not featured on CRAN yet\r\n# install.packages(\"remotes\")\r\n# remotes::install_github(\"wmgeolab/rgeoboundaries\")\r\n\r\nlibrary(rgeoboundaries)\r\n\r\ngb_adm0()\r\n\r\n\r\nSimple feature collection with 198 features and 5 fields\r\nGeometry type: MULTIPOLYGON\r\nDimension:     XY\r\nBounding box:  xmin: -180 ymin: -89.99893 xmax: 180 ymax: 83.58869\r\nGeodetic CRS:  WGS 84\r\nFirst 10 features:\r\n      shapeName shapeISO           shapeID shapeGroup shapeType\r\n1          Cuba      CUB CUB-ADM0-3_0_0-B1        CUB      ADM0\r\n2       Denmark      DNK DNK-ADM0-3_0_0-B1        DNK      ADM0\r\n3  Saudi Arabia      SAU SAU-ADM0-3_0_0-B1        SAU      ADM0\r\n4         Yemen      YEM YEM-ADM0-3_0_0-B1        YEM      ADM0\r\n5         Italy      ITA ITA-ADM0-3_0_0-B1        ITA      ADM0\r\n6       Comoros      COM COM-ADM0-3_0_0-B1        COM      ADM0\r\n7         Gabon      GAB GAB-ADM0-3_0_0-B1        GAB      ADM0\r\n8        Norway      NOR NOR-ADM0-3_0_0-B1        NOR      ADM0\r\n9    Kyrgyzstan      KGZ KGZ-ADM0-3_0_0-B1        KGZ      ADM0\r\n10        Tonga      TON TON-ADM0-3_0_0-B1        TON      ADM0\r\n                         geometry\r\n1  MULTIPOLYGON (((-78.38432 2...\r\n2  MULTIPOLYGON (((11.19134 54...\r\n3  MULTIPOLYGON (((41.75838 16...\r\n4  MULTIPOLYGON (((53.28007 12...\r\n5  MULTIPOLYGON (((8.48607 44....\r\n6  MULTIPOLYGON (((43.65672 -1...\r\n7  MULTIPOLYGON (((11.72096 2....\r\n8  MULTIPOLYGON (((7.26726 58....\r\n9  MULTIPOLYGON (((69.26495 39...\r\n10 MULTIPOLYGON (((-174.9152 -...\r\n\r\nggplot(gb_adm0()) + \r\n  geom_sf(color = \"grey40\", lwd = .2) + \r\n  coord_sf(crs = \"+proj=eqearth\") \r\n\r\n\r\n\r\n\r\nLower administrative levels are available as well, e.g.¬†in Germany\r\nadm1 represents federal states (‚ÄúBundesl√§nder‚Äù), adm2\r\ndistricts (‚ÄúKreise‚Äù) and so on.\r\nLet‚Äôs plot the admin 1 levels for the DACH countries:\r\n\r\n\r\ndach <- gb_adm1(c(\"germany\", \"switzerland\", \"austria\"), type = \"sscgs\")\r\n\r\nggplot(dach) +\r\n  geom_sf(aes(fill = shapeGroup)) +\r\n  scale_fill_brewer(palette = \"Set2\")\r\n\r\n\r\n\r\n\r\n{osmdata}\r\nOpenStreetMap (https://www.openstreetmap.org) is a collaborative\r\nproject to create a free editable geographic database of the world. The\r\ngeodata underlying the maps is considered the primary output of the\r\nproject and is accessible from R via the {osmdata}\r\npackage.\r\nWe first need to define our query and limit it to a region. You can\r\nexplore the features and tags (also available as information via\r\nOpenStreetMap directly).\r\n\r\n\r\n## install package\r\n# install.packages(\"osmdata\")\r\n\r\nlibrary(osmdata)\r\n\r\n## explore features + tags\r\nhead(available_features())\r\n\r\n\r\n[1] \"4wd_only\"  \"abandoned\" \"abutters\"  \"access\"    \"addr\"     \r\n[6] \"addr:city\"\r\n\r\nhead(available_tags(\"craft\"))\r\n\r\n\r\n[1] \"agricultural_engines\" \"atelier\"             \r\n[3] \"bakery\"               \"basket_maker\"        \r\n[5] \"beekeeper\"            \"blacksmith\"          \r\n\r\n## building the query, e.g. beekeepers\r\nbeekeeper_query <- \r\n  ## you can automatically retrieve a boudning box (pr specify one manually)\r\n  getbb(\"Berlin\") %>%\r\n  ## build an Overpass query\r\n  opq(timeout = 999) %>%\r\n  ## access particular feature\r\n  add_osm_feature(\"craft\", \"beekeeper\")\r\n  \r\n## download data\r\nsf_beekeepers <- osmdata_sf(beekeeper_query)\r\n\r\n\r\n\r\nNow we can investigate beekeepers in Berlin:\r\n\r\n\r\nnames(sf_beekeepers)\r\n\r\n\r\n[1] \"bbox\"              \"overpass_call\"     \"meta\"             \r\n[4] \"osm_points\"        \"osm_lines\"         \"osm_polygons\"     \r\n[7] \"osm_multilines\"    \"osm_multipolygons\"\r\n\r\nhead(sf_beekeepers$osm_points)\r\n\r\n\r\nSimple feature collection with 6 features and 25 fields\r\nGeometry type: POINT\r\nDimension:     XY\r\nBounding box:  xmin: 13.24443 ymin: 52.35861 xmax: 13.69093 ymax: 52.573\r\nGeodetic CRS:  WGS 84\r\n             osm_id name addr.city addr.country addr.housenumber\r\n358407135 358407135 <NA>      <NA>         <NA>             <NA>\r\n358407138 358407138 <NA>      <NA>         <NA>             <NA>\r\n417509803 417509803 <NA>      <NA>         <NA>             <NA>\r\n417509805 417509805 <NA>      <NA>         <NA>             <NA>\r\n597668310 597668310 <NA>      <NA>         <NA>             <NA>\r\n597668311 597668311 <NA>      <NA>         <NA>             <NA>\r\n          addr.postcode addr.street addr.suburb contact.phone\r\n358407135          <NA>        <NA>        <NA>          <NA>\r\n358407138          <NA>        <NA>        <NA>          <NA>\r\n417509803          <NA>        <NA>        <NA>          <NA>\r\n417509805          <NA>        <NA>        <NA>          <NA>\r\n597668310          <NA>        <NA>        <NA>          <NA>\r\n597668311          <NA>        <NA>        <NA>          <NA>\r\n          contact.website craft email facebook instagram man_made\r\n358407135            <NA>  <NA>  <NA>     <NA>      <NA>     <NA>\r\n358407138            <NA>  <NA>  <NA>     <NA>      <NA>     <NA>\r\n417509803            <NA>  <NA>  <NA>     <NA>      <NA>     <NA>\r\n417509805            <NA>  <NA>  <NA>     <NA>      <NA>     <NA>\r\n597668310            <NA>  <NA>  <NA>     <NA>      <NA>     <NA>\r\n597668311            <NA>  <NA>  <NA>     <NA>      <NA>     <NA>\r\n          opening_hours operator organic phone product shop source\r\n358407135          <NA>     <NA>    <NA>  <NA>    <NA> <NA>   <NA>\r\n358407138          <NA>     <NA>    <NA>  <NA>    <NA> <NA>   <NA>\r\n417509803          <NA>     <NA>    <NA>  <NA>    <NA> <NA>   <NA>\r\n417509805          <NA>     <NA>    <NA>  <NA>    <NA> <NA>   <NA>\r\n597668310          <NA>     <NA>    <NA>  <NA>    <NA> <NA>   <NA>\r\n597668311          <NA>     <NA>    <NA>  <NA>    <NA> <NA>   <NA>\r\n          website wheelchair works                  geometry\r\n358407135    <NA>       <NA>  <NA> POINT (13.69068 52.35918)\r\n358407138    <NA>       <NA>  <NA> POINT (13.69093 52.35894)\r\n417509803    <NA>       <NA>  <NA> POINT (13.68991 52.35888)\r\n417509805    <NA>       <NA>  <NA>  POINT (13.6902 52.35861)\r\n597668310    <NA>       <NA>  <NA>   POINT (13.24445 52.573)\r\n597668311    <NA>       <NA>  <NA> POINT (13.24443 52.57295)\r\n\r\nbeekeper_locations <- sf_beekeepers$osm_points\r\n\r\n## Berlin borders via {geoboundaries}\r\nsf_berlin <- gb_adm1(c(\"germany\"), type = \"sscgs\")[6,] # the sixth element is Berlin\r\n\r\n## Berlin border incl. district borders via our {d6berlin}\r\n# remotes::install_github(\"EcoDynIZW/d6berlin\")\r\nsf_berlin <- d6berlin::sf_districts\r\n\r\nggplot(beekeper_locations) + \r\n  geom_sf(data = sf_berlin, fill = \"grey10\", color = \"grey30\") +\r\n  geom_sf(size = 4, color = \"#FFB000\", alpha = .3) +\r\n  labs(title = \"Beekeepers in Berlin\",\r\n       caption = \"¬© OpenStreetMap contributors\")\r\n\r\n\r\n\r\n\r\n{elevatr}\r\nThe {elevatr}\r\n(https://github.com/jhollist/elevatr/) is an R package\r\nthat provides access to elevation data from AWS Open Data Terrain Tiles\r\nand the Open Topography Global data sets API for raster digital\r\nelevation models (DEMs).\r\nWe first need to define a location or bounding box for our elevation\r\ndata. This can either be a data frame or a spatial object. We use an\r\nsf object which holds the projection to be used when\r\nassessing the elevation data:\r\n\r\n\r\n## install package\r\n# install.packages(\"elevatr\")\r\n\r\nlibrary(elevatr)\r\n\r\n## manually specify corners of the bounding box of the US\r\nbbox_usa <- data.frame(x = c(-125.0011, -66.9326), \r\n                       y = c(24.9493, 49.5904))\r\n\r\n## turn into spatial, projected bounding box\r\nsf_bbox_usa <- sf::st_as_sf(bbox_usa, coords = c(\"x\", \"y\"), crs = 4326)\r\n\r\n\r\n\r\nNow we can download the elevation data with a specified resolution z\r\n(ranging from 1 to 14 with 1 being very coarse and 14 being very\r\nfine).\r\n\r\n\r\nelev_usa <- get_elev_raster(locations = sf_bbox_usa, z = 5)\r\n\r\nterra::plot(elev_usa)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "https://raw.githubusercontent.com/EcoDynIZW/EcoDynIZW.github.io/main/img/wiki/preview-r-spatial-data.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/d6geodatapackage/",
    "title": "Manage Spatial Data from Our Geodata Archive",
    "description": "Learn how to use the {d6geodata} R package that provides functions for accessing data from the Geodata archive of the Department of Ecological Dynamics. The two functions `geo_overview()` and `get_geodata()` are the main components for all members of our Department. Several other functions are within this package but only meant to be used by the Geodata Manager of the Department.",
    "author": [
      {
        "name": "Moritz Wenzler-Meya",
        "url": {}
      }
    ],
    "date": "2023-03-03",
    "categories": [
      "tutorial",
      "spatial",
      "rstats"
    ],
    "contents": "\r\nThe {d6geodata} package aims to access the data from the Geodata archive of the EcoDyn Department for members only!\r\nThe two main functions are:\r\ngeo_overview()\r\nget_geodata()\r\n\r\n\r\n## remotes::install_github(\"EcoDynIZW/d6geodata\")\r\n## library(d6geodata)\r\n\r\n\r\nIf you want to work with geodata that is already stored in our Geodata archive you have two options:\r\nGo to the EcoDynIZW Website, click on wikis and select Geodata. There you find several spatial data sets with respective metadaat and visualizations. In the metadata section, you‚Äôll find the information . To donwload the data, cope the folder_name information provided in the metadata and use it as an input in the get_geodata() function from our {d6geodata} to get the data from our PopDynCloud. Another option is the function called geo_overview(). There you can select which data and from which location you want to have a list of data.\r\nIf you run the function geo_overview you have to decide if you want to see the raw or processed data by typing 1 for raw and 2 for processed data. Afterwards, you have to decide if you want to see the main (type 1) folders (the regions or sub-regions we have data from) or the sub (type 2) folders (the actually data we have in each region).\r\nExample 1: Main Folder\r\n\r\nd6geodata::geo_overview(path_to_cloud = \"E:/PopDynCloud\")\r\nRaw or processed data: \r\n\r\n1: raw\r\n2: processed\r\n\r\nAuswahl: 2\r\nchoose folder type: \r\n\r\n1: main\r\n2: sub\r\n\r\nAuswahl: 1\r\n[1] \"atlas\" \"BB_MV_B\" \"berlin\" \"europe\" \"germany\" \"world\"\r\n\r\nExample 2: Sub Folder\r\n\r\nd6geodata::geo_overview(path_to_cloud = \"E:/PopDynCloud\")\r\nRaw or processed data: \r\n\r\n1: raw\r\n2: processed\r\n\r\nAuswahl: 2\r\nchoose folder type: \r\n\r\n1: main\r\n2: sub\r\n\r\nAuswahl: 2\r\n$atlas\r\n[1] \"distance-to-human-settlements_atlas_2009_1m_03035_tif\"\r\n[2] \"distance-to-kettleholes_atlas_2022_1m_03035_tif\"      \r\n[3] \"distance-to-rivers_atlas_2009_1m_03035_tif\"           \r\n[4] \"distance-to-streets_atlas_2022_1m_03035_tif\"          \r\n[5] \"landuse_atlas_2009_1m_03035_tif\"                      \r\n\r\n$BB_MV_B\r\n[1] \"_archive\" \"_old_not_verified\" \"dist_path_bb_agroscapelabs\"\r\n[4] \"scripts\"                   \r\n\r\n$berlin\r\n [1] \"_old_not_verified\"                            \r\n [2] \"corine_berlin_2015_20m_03035_tif\"            \r\n [3] \"distance-to-paths_berlin_2022_100m_03035_tif\" \r\n [4]  \"green-capacity_berlin_2020_10m_03035_tif\"    \r\n [5] \"imperviousness_berlin_2018_10m_03035_tif\"     \r\n [6]  \"light-pollution_berlin_2021_100m_03035_tif\"  \r\n [7] \"light-pollution_berlin_2021_10m_03035_tif\"    \r\n [8]  \"motorways_berlin_2022_100m_03035_tif\"        \r\n [9] \"noise-day-night_berlin_2017_10m_03035_tif\"    \r\n[10]  \"population-density_berlin_2019_10m_03035_tif\"\r\n[11] \"template-raster_berlin_2018_10m_03035_tif\"    \r\n[12] \"tree-cover-density_berlin_2018_10m_03035_tif\"\r\n\r\n$europe\r\n[1] \"imperviousness_europe_2018_10m_03035_tif\"\r\n\r\n$germany\r\n [1] \"_old_not_verified\"                                          \r\n [2] \"distance-to-motorway-rural-road_germany_2022_100m_03035_tif\"\r\n [3] \"distance-to-motorways_germany_2022_100m_03035_tif\"          \r\n [4] \"distance-to-paths_germany_2022_100m_03035_tif\"              \r\n [5] \"distance-to-roads-paths_germany_2022_100m_03035_tif\"        \r\n [6] \"distance-to-roads_germany_2022_100m_03035_tif\"              \r\n [7] \"distance_to_paths_germany_2022_100m_03035_tif\"              \r\n [8] \"motoroways_germany_2022_03035_osm_tif\"                      \r\n [9] \"motorway-rural-road_germany_2022_100m_03035_tif\"            \r\n[10] \"motorways_germany_2022_100m_03035_tif\"                      \r\n[11] \"paths_germany_2022_100m_03035_tif\"                          \r\n[12] \"Roads-germany_2022_100m_03035_tif\"                          \r\n[13] \"roads_germany_2022_100m_03035_tif\"                          \r\n[14] \"tree-cover-density_germany_2015_100m_03035_tif\"             \r\n\r\n$world\r\ncharacter(0)\r\n\r\nNow you can copy the name of one of the layers and paste it into the get_geodata() function\r\n\r\n\r\ncorine <-\r\n  d6geodata::get_geodata(\r\n    data_name = \"corine_berlin_2018_20m_03035_tif\",\r\n    path_to_cloud = \"E:/PopDynCloud\",\r\n    download_data = FALSE\r\n  )\r\n\r\n\r\nIf you set download_data = TRUE the data will be download and copied to your data-raw folder. If the data-raw folder doesn‚Äôt exist, it will be created.\r\nIf you want to download more than one file, you can simply use lapply() and add multiple file names like this:\r\n\r\n\r\ndata_list <-\r\n  lapply(\r\n    c(\r\n      \"corine_berlin_2018_20m_03035_tif\",\r\n      \"motorways_berlin_2022_100m_03035_tif\"\r\n    ),\r\n    FUN = function(x) {\r\n      d6geodata::get_geodata(\r\n        data_name = x,\r\n        path_to_cloud = \"E:/PopDynCloud\",\r\n        download_data = FALSE\r\n      )})\r\n\r\n\r\nAdditional functions\r\nThe three functions plot_binary_map(), plot_qualitative_map() and plot plot_quantitative_map() can be used to plot raster data with the respective color schemes we used for the Geodata wiki page (note that this function works only for raster data).\r\n\r\n\r\nplot_binary_map(tif = tif)\r\nplot_qualitative_map(tif = tif)\r\nplot_quantitative_map(tif = tif)\r\n\r\n\r\nExample plot\r\n\r\n\r\nlibrary(d6geodata)\r\nplot_qualitative_map(tif = corine)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/d6geodatapackage/d6geodatapackage_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/d6berlin-fisbroker/",
    "title": "Download Spatial Data from the Berlin FIS-Broker Data Base in R",
    "description": "Learn how to download WFS (vector) data and ATOM (raster) data from the Berlin fisbroker data base using the our custom functions `download_fisbroker_wfs()` and `download_fisbroker_atom()`.",
    "author": [
      {
        "name": "Moritz Wenzler-Meya",
        "url": {}
      }
    ],
    "date": "2023-02-15",
    "categories": [
      "tutorial",
      "spatial",
      "rstats",
      "data sources",
      "Berlin"
    ],
    "contents": "\r\n\r\nContents\r\nThe FIS-Broker database\r\nWFS Data\r\nATOM Data\r\n\r\nThe {d6berlin} package provides several functions for the members of the Ecological Department of the IZW. Now two functions are added to the package: download_fisbroker_wfs() and download_fisbroker_atom().\r\n\r\n\r\ninstall.packages(\"remotes\")\r\nremotes::install_github(\"EcoDynIZW/d6berlin\")\r\ninstall.packages(\"rcartocolor\")\r\ninstall.packages(\"stars\")\r\n\r\n\r\n\r\n\r\nlibrary(d6berlin)\r\nlibrary(dplyr)\r\nlibrary(ggplot2)\r\n\r\n\r\nThe FIS-Broker database\r\nThe FIS-Broker database is hosted by the Berlin Senate and provides several geographical data sets. The file formats differ and some data sets have just one of the file formats to offer. The file formats are WMS (Web Media Service: just like a png or jpg), WFS (Web Feature Service: Shapefiles) and ATOM (xml format: raster layers data). This function is only looking for WFS files (shapefiles), because these are the polygons, lines or points that we are looking for.\r\nFor using these two functions you have to select the layer you aim to download from the online data base.\r\nWFS Data\r\nAs an example we will download the layer containing the districts of Berlin (‚ÄúALKIS Bezirke‚Äù):\r\n\r\n\r\n\r\nurl <- \"https://fbinter.stadt-berlin.de/fb/wfs/data/senstadt/s_wfs_alkis_bezirk\"\r\n\r\ndata_wfs <- d6berlin::download_fisbroker_wfs(link = url)\r\n\r\nReading layer `s_wfs_alkis_bezirk' from data source \r\n  `https://fbinter.stadt-berlin.de/fb/wfs/data/senstadt/s_wfs_alkis_bezirk?service=wfs&version=2.0.0&request=GetFeature&typenames=s_wfs_alkis_bezirk&srsName=EPSG%3A25833' \r\n  using driver `GML'\r\nSimple feature collection with 12 features and 6 fields\r\nGeometry type: MULTIPOLYGON\r\nDimension:     XY\r\nBounding box:  xmin: 370000.8 ymin: 5799521 xmax: 415786.6 ymax: 5837259\r\nProjected CRS: ETRS89 / UTM zone 33N\r\n\r\nglimpse(data_wfs)\r\n\r\nRows: 12\r\nColumns: 7\r\n$ gml_id <chr> \"s_wfs_alkis_bezirk.445\", \"s_wfs_alkis_bezirk.446\", \"‚Ä¶\r\n$ gem    <int> 3, 12, 8, 10, 6, 9, 4, 1, 11, 7, 5, 2\r\n$ namgem <chr> \"Pankow\", \"Reinickendorf\", \"Neuk√∂lln\", \"Marzahn-Helle‚Ä¶\r\n$ namlan <chr> \"Berlin\", \"Berlin\", \"Berlin\", \"Berlin\", \"Berlin\", \"Be‚Ä¶\r\n$ lan    <int> 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11\r\n$ name   <int> 11000003, 11000012, 11000008, 11000010, 11000006, 110‚Ä¶\r\n$ geom   <MULTIPOLYGON [m]> MULTIPOLYGON (((399003.5 58..., MULTIPOLYGON (((38999‚Ä¶\r\n\r\nggplot() +\r\n  geom_sf(data = data_wfs, aes(fill = namgem)) +\r\n  rcartocolor::scale_fill_carto_d(palette = \"Bold\")\r\n\r\n\r\n\r\nYou got a spatial layer which you can save to disk or to use it directly.\r\nATOM Data\r\nAs an example we will download a raster of vegetation heights (‚ÄúVegetationsh√∂hen 2020 (Umweltatlas)‚Äù):\r\n\r\n\r\n\r\nurl <- \"https://fbinter.stadt-berlin.de/fb/atom/Vegetationshoehen/veghoehe_2020.zip\"\r\n\r\ndata_atom <-\r\n  d6berlin::download_fisbroker_atom(\r\n    zip_link = url,\r\n    path = here::here(\"_posts\", \"d6berlin-fisbroker\", \"man\"),\r\n    name = \"vegetation_heights\"\r\n  )\r\n\r\nglimpse(data_atom)\r\n\r\nS4 class 'SpatRaster' [package \"terra\"]\r\n\r\ndata_atom_10 <- terra::aggregate(data_atom, 10)\r\n\r\n\r\n\r\n\r\nggplot() +\r\n  stars::geom_stars(data = stars::st_as_stars(data_atom_10)) +\r\n  coord_sf(expand = FALSE) + \r\n  rcartocolor::scale_fill_carto_c(\r\n    palette = \"Emrld\", name = NULL, \r\n    guide =  guide_legend(label.position = \"bottom\")\r\n  ) + \r\n  theme_void()\r\n\r\n\r\n\r\nA shortcut to plot this kind of data is the plot_qualitative_map() function from our dedicated {d6geodata} package. You can install this package with devtools::install_github(‚ÄúEcoDynIZW/d6geodata‚Äù).\r\n\r\n\r\nd6geodata::plot_quantitative_map(tif = data_atom_10)\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/d6berlin-fisbroker/d6berlin-fisbroker_files/figure-html5/unnamed-chunk-1-1.png",
    "last_modified": "2023-10-30T11:29:36+01:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/NLRX/",
    "title": "Run NetLogo Simulations in R",
    "description": "Learn how to use the {NLRX} R package to run NetLogo models/experiments. This guide gives a brief overview of the basic functionality, how to quickly apply it to a model and shows some example (visual) outputs.",
    "author": [
      {
        "name": "Tobias K√ºrschner",
        "url": {}
      }
    ],
    "date": "2022-11-23",
    "categories": [
      "tutorial",
      "NetLogo",
      "rstats",
      "modelling"
    ],
    "contents": "\r\n\r\nContents\r\nLibraries and Folders\r\nSetting Up the Library to Work with Your NetLogo Model\r\nCreating an Experiment\r\nCreating a Simulation\r\nRunning the Experiment\r\nNLRX output handling\r\n\r\nCleaning the data\r\nExample plots\r\n\r\nThe NLRX package provides tools to setup and execute NetLogo simulations from R developed by Salecker et al.¬†2019. NetLogo is a free, open-source and cross-platform modelling environment for simulating natural and social phenomena.\r\nLibraries and Folders\r\n\r\n\r\n# libraries\r\n\r\nfor (pckg in c('dplyr', 'ggplot2', 'scico', 'nlrx'))\r\n{\r\n  if (!require(pckg, character.only = TRUE))\r\n    install.packages(pckg, dependencies = TRUE)\r\n  require(pckg, character.only = TRUE)\r\n}\r\n\r\n# output folder\r\n\r\ncurrentDate <- gsub(\"-\", \"\", Sys.Date())\r\n# todaysFolder <- paste(\"Output\", currentDate, sep = \"_\")\r\n# dir.create(todaysFolder) #in case output folder is wanted\r\n\r\n#virtual-ram if needed\r\n#memory.limit(85000)\r\n\r\n\r\nSetting Up the Library to Work with Your NetLogo Model\r\n\r\n\r\n#NetLogo path\r\nnetlogoPath <- file.path(\"C:/Program Files/NetLogo 6.2.2/\")\r\n\r\n#Model location\r\nmodelPath <- file.path(\"./Model/myModel.nlogo\")\r\n\r\n#Output location (hardly ever used)\r\noutPath <- file.path(\"./\")\r\n\r\n#Java\r\nSys.setenv(JAVA_HOME=\"C:/Program Files/Java/jre1.8.0_331\") \r\n\r\n\r\nConfigure the NetLogo object:\r\n\r\n\r\nnl <- nlrx::nl(\r\n  nlversion = \"6.2.2\",\r\n  nlpath = netlogoPath,\r\n  modelpath = modelPath,\r\n  jvmmem = 1024 # Java virtual machine memory capacity\r\n)\r\n\r\n\r\nCreating an Experiment\r\n\r\n\r\nnl@experiment <- nlrx::experiment(\r\n  expname = 'Exp_1_1',\r\n  # name\r\n  outpath = outPath,\r\n  # outpath\r\n  repetition = 1,\r\n  # number of times the experiment is repeated with the !!!SAME!!! random seed\r\n  tickmetrics = 'true',\r\n  # record metrics at every step\r\n  idsetup = 'setup',\r\n  # in-code setup function\r\n  idgo = 'go',\r\n  # in-code go function\r\n  runtime = 200,\r\n  # soft runtime-cap\r\n  metrics = c('population',  # global variables to be recorded, can also use NetLogos 'count' e.g. count turtles\r\n              'susceptible', # but requires escaped quotation marks for longer commands when strings are involved\r\n              'infected',    # functions similar for both patch and turtle variables (below)\r\n              'immune'),\r\n  metrics.patches = c('totalINfectionsHere',\r\n                      'pxcor',\r\n                      'pycor'),\r\n # metrics.turtles = list(\r\n #   \"turtles\" = c(\"xcor\", \"ycor\")\r\n # ),\r\n  constants = list(  # model parameters that are fixed. In theory all the constant values set in the UI before saving are the ones used\r\n    'duration' = 20, # however, I would always make sure to 'fix\" them though the constant input\r\n    'turtle-shape' = \"\\\"circle\\\"\",\r\n    'runtime' = 5\r\n  ),\r\n  variables = list( # model parameters you want to 'test' have several ways to be set\r\n    'number-people' = list(values = c(150)),     # simple list of values\r\n    'infectiousness' = list(                      #stepwise value change\r\n      min = 50,\r\n      max = 100,\r\n      step = 25,\r\n      qfun = 'qunif'\r\n    ),\r\n    # string based inputs such as used in NetLogo's 'choosers' or inputs require escaped quotation marks\r\n    # \"turtle-shape\" = list(values = c(\"\\\"circle\\\"\",\"\\\"person\\\"\")), \r\n    'chance-recover' = list(values = c(50, 75, 95))\r\n  )\r\n)\r\n\r\n\r\nCreating a Simulation\r\nHere we have several choices of simulation types. The full factorial simdesign used below creates a full-factorial parameter matrix with all possible combinations of parameter values. There are however, other options to choose from if needed and the vignette provides a good initial overview.\r\nA bit counter intuitive but nseeds used in the simdesign is actually the number of repeats we want to use for our simulation. In case we set nseed = 10 and have set the the repetitions above to 1, we would run each parameter combination with 10 different random seeds i.e.¬†10 times per combination. If we would have set the repetitions to 2 we would run each random seed 2 times i.e.¬†20 times in total but twice for each seed so 2 results should be identical.\r\nHowever, if your model handles seeds internally such as setting a random seed every time the model is setup, repetitions could be used instead.\r\n\r\n\r\nnl@simdesign <- nlrx::simdesign_ff(nl=nl, nseeds=1) \r\n\r\nprint(nl)\r\n\r\nnlrx::eval_variables_constants(nl)\r\n\r\n\r\nRunning the Experiment\r\nSince the simulations are executed in a nested loop where the outer loop iterates over the random seeds of the simdesign, and the inner loop iterates over the rows of the parameter matrix. These loops can be executed in parallel by setting up an appropriate plan from the future package which is built into nlrx.\r\n\r\n\r\n#plan(multisession, workers = 12) # one worker represents one CPU thread\r\n\r\nresults<- nlrx::run_nl_all(nl = nl)\r\n\r\n\r\nto speed up this this tutorial we load a pre-generated simulation result\r\n\r\n\r\nresults <- readr::read_rds(\"example1.rds\")\r\n\r\ndplyr::glimpse(results)\r\n\r\nRows: 1,809\r\nColumns: 15\r\n$ `[run number]`   <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1‚Ä¶\r\n$ `number-people`  <dbl> 150, 150, 150, 150, 150, 150, 150, 150, 150‚Ä¶\r\n$ infectiousness   <dbl> 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,‚Ä¶\r\n$ `chance-recover` <dbl> 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,‚Ä¶\r\n$ duration         <dbl> 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,‚Ä¶\r\n$ `turtle-shape`   <chr> \"circle\", \"circle\", \"circle\", \"circle\", \"ci‚Ä¶\r\n$ runtime          <dbl> 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5‚Ä¶\r\n$ `random-seed`    <dbl> -662923684, -662923684, -662923684, -662923‚Ä¶\r\n$ `[step]`         <dbl> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1‚Ä¶\r\n$ population       <dbl> 0, 153, 155, 156, 156, 157, 158, 159, 160, ‚Ä¶\r\n$ susceptible      <dbl> 0, 10, 10, 10, 11, 11, 13, 13, 16, 16, 17, ‚Ä¶\r\n$ infected         <dbl> 0, 143, 145, 146, 145, 146, 145, 146, 144, ‚Ä¶\r\n$ immune           <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0‚Ä¶\r\n$ metrics.patches  <list> [<tbl_df[1225 x 5]>], [<tbl_df[1225 x 5]>]‚Ä¶\r\n$ siminputrow      <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1‚Ä¶\r\n\r\nNLRX output handling\r\nThere are several ways to use / analyze the output directly via nlrx (although I have not used them personally) detailed information can be found here: https://cran.r-project.org/web/packages/nlrx/nlrx.pdf\r\n\r\n\r\nnlrx::setsim(nl, \"simoutput\") <- results # attaching simpout to our NetLogo object\r\n\r\n#write_simoutput(nl) # having nlrx write the output into a file only works without patch or turtle metrics\r\n\r\nnlrx::analyze_nl(nl, metrics = nlrx::getexp(nl, \"metrics\"), funs = list(mean = mean))\r\n\r\n\r\nCleaning the data\r\nNetLogo really dislikes outputting nice and readable variable names so some renaming is in order:\r\n\r\n\r\nraw1 <- results\r\n\r\nraw2 <-\r\n  raw1 %>% dplyr::rename(\r\n    run = `[run number]`,\r\n    recoveryChance = `chance-recover`,\r\n    StartingPop = `number-people`,\r\n    t = `[step]`\r\n  )\r\n\r\n\r\nIn case of very large datasets we want to separate the patch (or turtle) specific data from the global data to speed up the analysis of the global data\r\n\r\n\r\nglobalData <- raw2 %>% dplyr::select(!metrics.patches)#, !metrics.turtles)\r\n\r\n\r\nand summarise like any other dataset\r\n\r\n\r\nsum_1 <-\r\n  globalData %>%\r\n  dplyr::group_by(t, recoveryChance, infectiousness) %>%\r\n  dplyr::summarise(\r\n    across(\r\n      c('infected',\r\n        'immune',\r\n        'susceptible',\r\n        'population'),\r\n      mean\r\n    )\r\n  ) %>%\r\n  dplyr::filter(t < 201) %>%\r\n  tidyr::pivot_longer(cols = -c(recoveryChance, infectiousness, t),\r\n                      names_to = \"EpiStat\") %>%\r\n  dplyr::ungroup()\r\n\r\n\r\nExample plots\r\nWe use the global data to get an overview of the simulated SIR dynamics:\r\n\r\n\r\nggplot(sum_1) +\r\n  geom_line(aes(x = t, y = value, colour = EpiStat), size = 1) +\r\n  facet_grid(infectiousness ~ recoveryChance, labeller = label_both) +\r\n  scale_colour_scico_d(\r\n    palette = \"lajolla\",\r\n    begin = 0.1,\r\n    end = 0.9,\r\n    direction = 1\r\n  ) +\r\n  theme_bw()\r\n\r\n\r\n\r\n‚Ä¶ and use the patch specific data to create a heatmap to visualize where most infections have happened in one specific scenario:\r\n\r\n\r\nhmpRaw <- raw2 %>%\r\n  dplyr::filter(infectiousness == 75 & recoveryChance == 75) %>%\r\n  dplyr::select(metrics.patches, t) %>%\r\n  dplyr::rename(pm = metrics.patches)\r\n\r\nhmpSplit <- hmpRaw %>% split(hmpRaw$t)\r\ntempDf <- hmpSplit[[1]]$pm \r\ntempDf <- tempDf %>% as.data.frame() %>%\r\n  dplyr::select(totalINfectionsHere, pxcor, pycor)\r\n\r\nfor (i in 1:length(hmpSplit))\r\n{\r\n  tmp1 <- as.data.frame(hmpSplit[[i]]$pm)\r\n  colnames(tmp1) <- c(paste0(\"tab_\", i), 'pxcor', 'pycor', 'agent', 'breed')\r\n  tmp1 <- tmp1 %>% \r\n    dplyr::select(-c('pxcor', 'pycor', 'agent', 'breed'))\r\n  tempDf <- cbind(tempDf, tmp1)\r\n}\r\n\r\ntempDf2 <- tempDf %>% \r\n  dplyr::select(-c(pxcor, pycor)) \r\n\r\ntempDf$summ <- rowSums(tempDf2)\r\nhmpData <- tempDf %>% dplyr::select(summ, pxcor, pycor)\r\n\r\nggplot(hmpData)+\r\n  geom_tile(aes(x = pxcor, y = pycor, fill = summ)) +\r\n  scale_fill_scico(palette = 'roma', direction = -1, name= 'N infected') +\r\n  ggtitle(\"N infections per cell\") +\r\n  theme_bw()\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/NLRX/nlrxpackage_files/figure-html5/spatial-plots-1.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {},
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/coding-basics/",
    "title": "Coding Basics 2: Loops and Functions",
    "description": "A brief introduction into various coding basics for people who are beginning to use R or other programming languages. In this session, we will be looking at both functions and loops in R, with examples from NetLogo and C++ and go over use and basic functionality.",
    "author": [
      {
        "name": "Tobias K√ºrschner",
        "url": {}
      }
    ],
    "date": "2022-11-14",
    "categories": [
      "tutorial",
      "workflow",
      "rstats",
      "NetLogo"
    ],
    "contents": "\r\n\r\nContents\r\nFunctions and Loops\r\nWhat are they for?\r\nFunctions\r\nLoops\r\nA Classic, the ‚Äòfor‚Äô Loop\r\n‚Äòwhile‚Äô Loops\r\n\r\nBonus Round: Conditionals\r\n\r\n\r\n\r\n\r\n\r\nFunctions and Loops\r\nWhat are they for?\r\nIn short: making you life easier. They are used to automate certain steps in your code to make the execution faster.\r\nFunctions\r\nA simple example: you have multiple data sets with a measurement in inches. To continue working with that data you need to convert it meter, but doing that manually would take hours. Solution: a function!!\r\nIn R:\r\n\r\n\r\ninch_to_meter <-   #function name\r\n  function(inch) #function input parameter(s)\r\n  { # function body\r\n    inM <- (inch * 0.0254) # in our case: transformation\r\n    \r\n    return(inM) # function reporter\r\n  }\r\n\r\n\r\nNow lets apply that function to some random example data:\r\n\r\n\r\nmyOldData <- c(15,98,102,5,17)\r\n\r\nmyNewData <- inch_to_meter(myOldData)\r\n\r\n\r\nOur function is applied to all elements of the old data, giving us the converted measurements.\r\n\r\n\r\nmyOldData\r\n\r\n[1]  15  98 102   5  17\r\n\r\nmyNewData\r\n\r\n[1] 0.3810 2.4892 2.5908 0.1270 0.4318\r\n\r\nFor a more general approach we can use the following template for simple functions:\r\n\r\n\r\nmyFunction <-\r\n  function(input1, input2, input3)\r\n  {\r\n    output <- input1 * input3 / input2 # example operation\r\n    \r\n    return(output)\r\n  }\r\n\r\n\r\nIn C++:\r\n\r\n# the viableCell function of the class Grid returns a bool and takes two inputs\r\n# (x and y coordinates)\r\nbool Grid::viableCell(CellCount_t x, CellCount_t y) \r\n{\r\n    return !m_grid.empty() && x < m_grid.cbegin() -> size() && y < m_grid.size();\r\n}\r\n\r\nIn NetLogo, the closest thing we have to functions are reporters:\r\n\r\nto-report Male_Alpha_Alive \r\n\r\n  ifelse (any? turtles-here with [isAlpha = true AND isFemale = false])\r\n  [report true]\r\n  [report false] #else\r\n\r\nend\r\n\r\nLoops\r\nWhat is a loop? It a simply a piece of code we want to repeat. But wait, isn‚Äôt that exactly what a function does? Well, yes and no. A function (after it is declared) is an embodiment of a piece of code that we can run anytime just by calling it. A loop is a local repetition of code.\r\nLets stay in R and look at some examples:\r\nA Classic, the ‚Äòfor‚Äô Loop\r\nIf you auto fill ‚Äúfor‚Äù in R, it will give you the following structure:\r\n\r\n\r\nfor (variable in vector)\r\n{\r\n  #body\r\n}\r\n\r\n\r\nSo what is variable and what is vector? In this case the variable, you could also call iterator (often you will see the letter i used) is simply put a counter that tells our loop how many times it has repeated itself. The vector is determined by us and tells the loop how many repetitions we want before it stops.\r\n\r\n\r\nfor (i in 1:10)\r\n{\r\n  #body\r\n}\r\n\r\n\r\nThe loop above will now repeat exactly 10 times and then stop. R is helpful in the sense that it automatically increments i after each repetition. Other language like C++ for example need a manual increment of i:\r\n\r\nfor (i = 0, i <= 10, ++i) #C++ \r\n{\r\n  #body\r\n}\r\n\r\nWith the basics out of the way lets look at an example:\r\n\r\n\r\nmyData <- rnorm(30) # random numbers\r\nmyResults <- 0 # initializing myResults\r\n\r\nfor(i in 1:10)\r\n{\r\n  # i-th element of `myData` squared into `i`-th position of `myResults`\r\n  myResults[i] <- myData[i] * myData[i]  \r\n  print(i)\r\n}\r\n\r\n[1] 1\r\n[1] 2\r\n[1] 3\r\n[1] 4\r\n[1] 5\r\n[1] 6\r\n[1] 7\r\n[1] 8\r\n[1] 9\r\n[1] 10\r\n\r\nmyResults\r\n\r\n [1] 2.348470e+00 8.045558e-02 9.254717e+00 6.298287e-01 5.587004e-02\r\n [6] 5.496863e-01 2.161664e+00 1.326536e-05 2.026844e+00 2.065682e-01\r\n\r\nThis was of course a very simple loop and there is pretty much no limit to the level of complexity those loops can have and how many loops could be nested. But be warned there can be some pitfalls with loops. Exercise: Would the following loop work?\r\n\r\n\r\nfor (i in 1:length(summIdentSplit))\r\n{\r\n  tmpSumm <- summIdentSplit[[i]]\r\n  tmpName <- SummIdentVector[[i]]\r\n  \r\n  if (base::grepl(\"HD\", tmpName) == TRUE)\r\n  {\r\n    clearName <- \"Habitat-driven movement\"\r\n    cn <- \"HD\"\r\n  }\r\n  \r\n  combiMelt <- tmpSumm %>%\r\n    dplyr::ungroup() %>%\r\n    dplyr::select(t, Ninfected_mean, Nimmune_mean) %>%\r\n    dplyr::rename(Infected = Ninfected_mean, Immune = Nimmune_mean)\r\n  \r\n  combiMelt_sd <- tmpSumm %>%\r\n    dplyr::ungroup() %>%\r\n    dplyr::select(t, Ninfected_sd, Nimmune_sd) %>%\r\n    dplyr::rename(Inf_sd = Ninfected_sd, Imm_sd = Nimmune_sd)\r\n  \r\n  combiMelt_c <- dplyr::left_join(combiMelt, combiMelt_sd , by = \"t\")\r\n  \r\n  q <- 0\r\n  combiMelt_c$quarter <- 0\r\n  \r\n  for (i in 1:nrow(combiMelt_c))\r\n  {\r\n    if (i %% 13 == 0)\r\n    {\r\n      q <- q + 1\r\n    }\r\n    combiMelt_c$quarter[i] <- q\r\n  }\r\n}\r\n\r\n\r\nThe answer is no. There are two loops involved where one is nested inside the other. So far, that would not be an issue, however, both loops use the iterator (variable) i. To see what would happen:\r\n\r\nFirst iteration:\r\n  i = 1\r\n\r\nfor (i in 1:length(summIdentSplit))\r\n{\r\n  tmpSumm <- summIdentSplit[[i]]\r\n  tmpName <- SummIdentVector[[i]]\r\n  \r\n  if (base::grepl(\"HD\", tmpName) == TRUE)\r\n  {\r\n    clearName <- \"Habitat-driven movement\"\r\n    cn <- \"HD\"\r\n  }\r\n  \r\n  combiMelt <- tmpSumm %>%\r\n    dplyr::ungroup() %>%\r\n    dplyr::select(t, Ninfected_mean, Nimmune_mean) %>%\r\n    dplyr::rename(Infected = Ninfected_mean, Immune = Nimmune_mean)\r\n  \r\n  combiMelt_sd <- tmpSumm %>%\r\n    dplyr::ungroup() %>%\r\n    dplyr::select(t, Ninfected_sd, Nimmune_sd) %>%\r\n    dplyr::rename(Inf_sd = Ninfected_sd, Imm_sd = Nimmune_sd)\r\n  \r\n  combiMelt_c <- dplyr::left_join(combiMelt, combiMelt_sd , by = \"t\")\r\n  \r\n  q <- 0\r\n  combiMelt_c$quarter <- 0\r\n\r\nAt this point i is still 1 and lets say nrow(combiMelt_c) is also 10 (like in our outer loop)\r\n\r\n  for (i in 1:nrow(combiMelt_c))\r\n  {\r\n    if (i %% 13 == 0)\r\n    {\r\n      q <- q + 1\r\n    }\r\n    combiMelt_c$quarter[i] <- q\r\n\r\nat this point i is iterated within the inner loop\r\n\r\n  }\r\n\r\nonce we reach this point i is 10, so the for the next iteration of the outer\r\nloop, i = 10 so most iterations of the outer loop will be skipped!\r\n\r\n}\r\n\r\nSolution: make sure to use different iterators in nested loops. For example the outer loop uses i, the inner loop uses j and maybe that loop has also a nested loop which then uses k as its iterator.\r\n‚Äòwhile‚Äô Loops\r\nSimilar to for loops, while loops also repeat a certain block of code. The difference here is, that while loop repeat until a certain condition is fulfilled, potentially forever. R‚Äôs auto fill provides us the following code snippet:\r\n\r\n\r\nwhile (condition)\r\n{\r\n  \r\n}\r\n\r\n\r\nA simple example:\r\n\r\n\r\nn <- 0\r\n\r\nwhile(n < 100)\r\n{\r\n  n = n + 1\r\n}\r\n\r\nprint(n)\r\n\r\n[1] 100\r\n\r\nAs long as n is below 100 we increment n every repeat. Take note: if the condition is never fulfilled, the loop will run forever and the software might crash. In complex loops you could run a ‚Äúescape timer‚Äù such as in this example plucked from an IBM:\r\n\r\n\r\nwhile(!viableCell())\r\n{\r\n   turn(2 * (atan (( (1 - 0.5) / (1 + 0.9)) * tan ((randomDouble(1) - 0.5)) * 180)) + 1) \r\n}\r\n\r\n\r\nThis little loop runs on an individual and check‚Äôs the cell in front of the individual for its viability to move into. As long as viableCell() reports false, the individual turns. However, there are cases when they are no viable cells around so the individual would turn in a circle forever. Introducing a random timer (note, this is not an optimal solution just a quick fix).\r\n\r\nint timer = 0\r\n\r\nwhile(!viableCell() && timer < 50 )\r\n{\r\n   turn(2 * (atan (( (1 - 0.5) / (1 + 0.9)) * tan ((randomDouble(1) - 0.5)) * 180)) + 1) \r\n  \r\n  ++timer #increment the timer\r\n}\r\n\r\nNow the individual turns a maximum of 50 times before the loop ends. Another option would be conditionals:\r\nBonus Round: Conditionals\r\nMost people already know what a conditional is. Basically, when a certain condition is fulfilled something happens (usually done via if and/or else).\r\n\r\nint timer = 0\r\n\r\nwhile(!viableCell())\r\n{\r\n   turn(2 * (atan (( (1 - 0.5) / (1 + 0.9)) * tan ((randomDouble(1) - 0.5)) * 180)) + 1) \r\n  \r\n  ++timer #increment the timer\r\n  \r\n  if(timer == 50)\r\n  {\r\n    break # break is a function that for example ends a loop\r\n  }\r\n}\r\n\r\nConditionals can be used in a variety of way within and outside of loops but have the advantage that they can be used stop loops under certain conditions. Lets say you are running a complex construct of multiple nested for loops to find a certain value in your data. You don‚Äôt need to always iterate through all the data if you can create certain logical stop conditions.\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/coding-goodpractice/",
    "title": "Coding Basics 1: General Tips",
    "description": "A brief introduction into various coding basics for people who are beginning to use R or other programming languages. In this session, we will be looking at some general tips and information that helps creating good and understandable code. Specifically we are looking at naming conventions, indentations and commenting of code.",
    "author": [
      {
        "name": "Tobias K√ºrschner",
        "url": {}
      }
    ],
    "date": "2022-11-13",
    "categories": [
      "tutorial",
      "workflow",
      "rstats"
    ],
    "contents": "\r\n\r\nContents\r\nGeneral:\r\nVariable Naming Conventions\r\nSnakecase:\r\nCamelcase:\r\nPascalcase:\r\nHungarian Notation:\r\nSidenote: Namespaces and Function Names\r\n\r\nIndentation\r\nCommenting Your Code\r\nDon‚Äôt Repeat Yourself\r\n\r\nGeneral:\r\nWrite as few lines as possible.\r\nUse appropriate naming conventions.\r\nSegment blocks of code in the same section into paragraphs.\r\nUse indentation to marks the beginning and end of control structures.\r\nDon‚Äôt repeat yourself.\r\n\r\n\r\n\r\nVariable Naming Conventions\r\nVariable naming is an important aspect in making your code readable. Create variables that describe their function and follow a consistent theme throughout your code. Separate words in a variable name without the use of whitespace and do not repeat variable names (unless in certain circumstances such as temporary variable within loops).\r\nSnakecase:\r\nWords are delimited by an underscore.\r\n\r\n\r\nvariable_one <- 1\r\n\r\nvariable_two <- 2\r\n\r\n\r\nCamelcase:\r\nWords are delimited by capital letters, except the initial word.\r\n\r\n\r\nvariableOne <- 1\r\n\r\nvariableTwo <- 2\r\n\r\n\r\nPascalcase:\r\nWords are delimited by capital letters.\r\n\r\n\r\nVariableOne <- 1\r\n\r\nVariableTwo <- 2\r\n\r\n\r\nHungarian Notation:\r\nThis notation describes the variable type or purpose at the start of the variable name, followed by a descriptor that indicates the variable‚Äôs function. The Camelcase notation is used to delimit words.\r\n\r\n\r\niVariableOne   <- 1  # i - integer\r\n\r\nsVariableTwo   <- \"two\" # s - string\r\n\r\nlVariableThree <- list() # l - list\r\n\r\n\r\nSidenote: Namespaces and Function Names\r\nOften when using for example R we will use libraries and many of them at the same time. Quite a few of those libraries are using the same names for their functions. This can be a big issues and cause code to suddenly not run anymore even though the only difference my be the order in which libraries are loaded. The last library loaded with a certain function will be the default one used by R. A prominent example would be the ‚Äòraster‚Äô package and ‚Äòtidyverse‚Äô (dplyr) who share the name ‚Äòselect‚Äô for a function. So, when in doubt use namespaces to make sure to link a function to their library.\r\n\r\nuse the select function from the dplyr library\r\ndplyr::select(.....)\r\n\r\nIndentation\r\nI assume you already know that your code should have some sort of indentation. However, it‚Äôs also worth noting that its a good idea to keep your indentation style consistent.\r\nAs a quick reminder:\r\nBad:\r\nLong lines of text with no separation:\r\n\r\n\r\nmydata <- iris %>% dplyr::filter(Species == \"virginica\") %>% summarise_at(.vars = c(\"Sepal.Length\", \"Sepal.Width\"),.funs = \"mean\")\r\n\r\nfor (i in 1:length(hmpSplit)){ tmp1 <- as.data.frame(hmpSplit[[i]]$pm); colnames(tmp1) <- c(paste0(\"tab_\", i), 'pxcor', 'pycor', 'agent', 'breed'); tmp1 <- tmp1 %>% dplyr::select(-c('pxcor', 'pycor', 'agent', 'breed')); tempDf <- cbind(tempDf, tmp1)}\r\n\r\n\r\nGood:\r\n\r\n\r\nmydata <- iris %>%\r\n  dplyr::filter(Species == \"virginica\") %>%\r\n  summarise_at(.vars = c(\"Sepal.Length\", \"Sepal.Width\"),\r\n               .funs = \"mean\")\r\n\r\n\r\nfor (i in 1:length(hmpSplit))\r\n{\r\n  tmp1 <- as.data.frame(hmpSplit[[i]]$pm)\r\n  \r\n  colnames(tmp1) <- c(paste0(\"tab_\", i), 'pxcor', 'pycor', 'agent', 'breed')\r\n  \r\n  tmp1 <- tmp1 %>% \r\n    dplyr::select(-c('pxcor', 'pycor', 'agent', 'breed'))\r\n  \r\n  tempDf <- cbind(tempDf, tmp1)\r\n}\r\n\r\n\r\nThe details on how to indent or use white spaces are up to individual styles with some guidelines, such as avoiding long lines of text, to keep in mind. Also fine would be something like the following.\r\n\r\n\r\nfor (i in 1:length(hmpSplit))\r\n{\r\n  tmp1 <- as.data.frame(hmpSplit[[i]]$pm)\r\n  colnames(tmp1) <- c(paste0(\"tab_\", i), 'pxcor', 'pycor', 'agent', 'breed')\r\n  tmp1 <- tmp1 %>% dplyr::select(-c('pxcor', 'pycor', 'agent', 'breed'))\r\n  tempDf <- cbind(tempDf, tmp1)\r\n}\r\n\r\n\r\nCommenting Your Code\r\nCommenting your code is fantastic but it can be overdone or just be plain redundant. Comments should add information or explanations to make your code understandable for people who didn‚Äôt write it or yourself in a year from now:\r\n\r\n\r\n# comment that adds information:\r\n\r\nwrite_simoutput(nl) # having nlrx write the output into a file - only works without patch or turtle metrics\r\n\r\n\r\n# redundant comments:\r\n\r\nif (col == \"blue\") # if colour is blue\r\n{\r\n  print('colour is blue') # print that the colour is blue\r\n}\r\n\r\n\r\nA better solution (if a comment is absolutely necessary) would be:\r\n\r\n\r\n# display selected colour\r\nif (colour == \"blue\")\r\n{\r\n  print('colour is blue')\r\n}\r\n\r\n\r\nDon‚Äôt Repeat Yourself\r\nAs a rule of thumb, if you have to do the same task multiple times in your code: automate it. A while back, I was decomposing many time series and I needed only part of the output, in this case the ‚Äòtrend‚Äô. Instead of running the same lines of code that remove all other components for each time series individually, a short function reduced the amount of needed code substantially.\r\n\r\n\r\nDecompTrend <- function(ts){\r\n  \r\n  temp1<-stats::decompose(ts)\r\n  return(temp1$trend)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/netlogo-weibull/",
    "title": "Turning Equations into Functions in NetLogo",
    "description": "While some programming languages, such as R, offer many native functions, others (e.g., NetLogo) offer fewer built-in options. However, users can create their own functions easily. Here, we will show the example of a Weibull density distribution function & associated cumulative density distribution function‚Äîboth not yet implemented in NetLogo or NetLogo extensions.",
    "author": [
      {
        "name": "Marius Grabow",
        "url": {}
      }
    ],
    "date": "2022-11-11",
    "categories": [
      "NetLogo",
      "rstats",
      "distributions"
    ],
    "contents": "\r\n\r\nContents\r\nDensity distribution function\r\nR\r\nNetLogo\r\n\r\nCumulative density function\r\nR\r\nNetLogo\r\n\r\n\r\nDensity distribution\r\nfunction\r\nLet‚Äôs first take a look at the Weibull density distribution\r\nfunction:\r\n\\[\\begin{equation}\r\n\r\nf(x) = \\frac{\\gamma} {\\alpha} (\\frac{x-\\mu}\r\n{\\alpha})^{(\\gamma - 1)}\\exp{(-((x-\\mu)/\\alpha)^{\\gamma})}\r\n\\hspace{.3in}  x \\ge \\mu; \\gamma, \\alpha > 0\r\n\r\n\\end{equation}\\]\r\nR\r\nIn R, this is already implemented:\r\n\r\n\r\nscale <- 3\r\nshape <- 1\r\n\r\ndweibull(scale, shape = shape)\r\n\r\n\r\n[1] 0.04978707\r\n\r\nNetLogo\r\nIn Netlogo we can simply translate the mathematical equation into a\r\nfunction:\r\nto-report weibull [a_scale a_shape x]\r\n\r\n  let Wei (a_shape / a_scale ) * ((x / a_scale)^(a_shape - 1)) * exp( - ((x / a_scale)^ a_shape))\r\n\r\n  report Wei\r\n\r\nend\r\nCumulative density function\r\nLet‚Äôs also take a look at the Weibull cumulative density\r\nfunction:\r\n\\[\\begin{equation}\r\n\r\nF(x) = 1 - e^{-(x^{\\gamma})} \\hspace{.3in}  x \\ge 0; \\gamma > 0\r\n\r\n\\end{equation}\\]\r\nR\r\nAgain, fully implemented in R already:\r\n\r\n\r\nscale <- 3\r\nshape <- 1\r\nx <- 5\r\n\r\npweibull(q = x, scale = scale, shape = shape)\r\n\r\n\r\n[1] 0.8111244\r\n\r\nNetLogo\r\nIn NetLogo we can simply translate the mathematical equation into a\r\nfunction:\r\nto-report weibull_cumulative [a_scale a_shape x]\r\n\r\n  let Wei_cumu 1 - exp( - ((x / a_scale)^ a_shape))\r\n\r\n  report Wei_cumu\r\n\r\nend\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/imageseg/",
    "title": "imageseg",
    "description": "imageseg is an R package for deep learning image segmentation using the U-Net model architecture by Ronneberger (2015), implemented in Keras and TensorFlow. It provides pre-trained models for forest structural metrics (canopy density and understory vegetation density) and a workflow to apply these on custom images",
    "author": [
      {
        "name": "J√ºrgen Niedballa",
        "url": {}
      }
    ],
    "date": "2022-09-12",
    "categories": [],
    "contents": "\r\nimageseg\r\nR package for deep learning image segmentation using the U-Net model architecture by Ronneberger (2015), implemented in Keras and TensorFlow. It provides pre-trained models for forest structural metrics (canopy density and understory vegetation density) and a workflow to apply these on custom images.\r\nIn addition, it provides a workflow for easily creating model input and model architectures for general-purpose image segmentation based on the U-net architecture. Model can be trained on grayscale or color images, and can provide binary or multi-class image segmentation as output.\r\nThe package can be found on CRAN.\r\nThe preprint of the paper describing the package is available on bioRxiv.\r\nInstallation\r\nFirst, install the R package ‚ÄúR.rsp‚Äù which enables the static vignettes.\r\n\r\n\r\n\r\nInstall the imageseg package from CRAN via:\r\n\r\n\r\n\r\nAlternatively you can install from GitHub (requires remotes package and R.rsp):\r\n\r\n\r\n\r\nUsing imageseg requires Keras and TensorFlow. See the vignette for information about installation and initial setup:\r\nTutorial\r\nSee the vignette for an introduction and tutorial to imageseg.\r\n\r\n\r\n\r\nThe vignette covers:\r\n- Installation and setup\r\n- Sample workflow for canopy density assessments\r\n- Training new models\r\n- Continued training of existing models\r\n- Multi-class image segmentation models\r\n- Image segmentation based on grayscale images\r\nForest structure model download\r\nThe models, example predictions, training data and R script for model training for both the canopy and understory model are available from Dryad as a single download.\r\nSee the ‚ÄúUsage Notes‚Äù section for details on the dataset.\r\nThe models and script (without the training data) are also hosted on Zenodo and can be downloaded individually from zenodo.\r\nThe pre-trained models for forest canopy density and understory vegetation density are available for download. The zip files contain the model (as .hdf5 files) and example classifications to give an impression of model performance and output:\r\nCanopy model\r\nUnderstory model\r\nPlease see the vignette for further information on how to use these models.\r\nTraining data download\r\nTraining data for both the canopy and understory model are included in the Dryad dataset download in the zip files:\r\nimageseg_canopy_training_data.zip\r\nimageseg_understory_training_data.zip\r\nFor details, please see the Usage Notes and the info.txt files contained in the zip files.\r\nThe training data are not required for users who only wish to use the pre-trained models on their own images.\r\n\r\n\r\n\r\n",
    "preview": "https://raw.githubusercontent.com/EcoDynIZW/EcoDynIZW.github.io/main/img/wiki/hex-imageseg.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/isorix/",
    "title": "Isorix",
    "description": "IsoriX is an R package aiming at building isoscapes using mixed models and inferring the geographic origin of organisms based on their isotopic ratios",
    "author": [
      {
        "name": "Alexandre Courtiol",
        "url": {}
      }
    ],
    "date": "2022-09-12",
    "categories": [],
    "contents": "\r\nHow to download and install IsoriX?\r\nYou can download and install the stable version of IsoriX directly from within R by typing:\r\n\r\n\r\ninstall.packages(\"IsoriX\", dependencies = TRUE)\r\n\r\n\r\nNote: if you get into troubles due to gmp, magick, maps, maptools, RandomFields, rgeos, or rgl, retry using simply:\r\n\r\n\r\ninstall.packages(\"IsoriX\")\r\n\r\n\r\nThese packages offer additional functionalities but some of them are particularly difficult to install on some systems.\r\nIf you want the development version of IsoriX, you can download and install it by typing:\r\n\r\n\r\nremotes::install_github(\"courtiol/IsoriX/IsoriX\")\r\n\r\n\r\nMind that you need the R package remotes to be installed for that to work. Mind also that the development version, being under development, can sometimes be broken. So before downloading it make sure that the current build status is build passing. The current built status is provided at the top of this readme document.\r\nAlso, if you access the network via a proxy, you may experience troubles with install_github. In such case try something like:\r\n\r\n\r\nlibrary(httr)\r\nwith_config(use_proxy(\"192.168.2.2:3128\"), devtools::install_github(\"courtiol/IsoriX/IsoriX\"))\r\n\r\n\r\nOff course, unless you are in the same institute than some of us, replace the numbers with your proxy settings!\r\nWhere to learn about IsoriX?\r\nYou can start by reading our bookdown!\r\nThen, if may not be a bad idea to also have a look at our papers: here and there.\r\nAnother great source of help is our mailing list. First register for free (using your Google account) and then feel free to send us questions.\r\nFor specific help on IsoriX functions and objects, you should also check the documentation embedded in the package:\r\n\r\n\r\nhelp(package = \"IsoriX\")\r\n\r\n\r\nin R after having installed and attached (= loaded) the package.\r\nHow can you contribute?\r\nThere are plenty way you can contribute! If you are fluent in R programming, you can improve the code and develop new functions. If you are not so fluent, you can still edit the documentation files to make them more complete and clearer, write new vignettes, report bugs or make feature requests.\r\nSome useful links\r\n\r\n\r\n\r\n",
    "preview": "https://raw.githubusercontent.com/EcoDynIZW/EcoDynIZW.github.io/main/img/wiki/hex-isorix.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/camtrapr/",
    "title": "Manage Camera Trap Data in R",
    "description": "Learn how to use the {camtrapR} R package for streamlined and flexible camera trap data management. It should be most useful to researchers and practitioners who regularly handle large amounts of camera trapping data.",
    "author": [
      {
        "name": "J√ºrgen Niedballa",
        "url": {}
      }
    ],
    "date": "2022-05-23",
    "categories": [
      "tutorial",
      "rstats",
      "camera trapping",
      "data management"
    ],
    "contents": "\r\n\r\nContents\r\nInstallation\r\nExiftool\r\n\r\nThe {camtrapR} R package simplifies camera trap data management in R.\r\nInstallation\r\nYou can install the release version of {camtrapR} from CRAN:\r\n\r\n\r\ninstall.packages(\"camtrapR\")\r\n\r\n\r\nExiftool\r\nNumerous important {camtrapR} functions read EXIF metadata from JPG images (and videos). This is done via Exiftool, a free and open-source sofware tool developed by Phil Harvey and available for Windows, MacOS and Linux.\r\nTo make full use of {camtrapR}, you will need Exiftool on your system. You can download it from the Exiftool homepage and follow the installation instruction in vignette 1.\r\nYou may not need Exiftool if you do not work with image files, but only use {camtrapR} to create input for occupancy or spatial capture-recapture models from existing record tables.\r\nSee the article in Methods in Ecology and Evolution for an overview of the package. The five vignettes provide examples for the entire workflow.\r\nCitation\r\n\r\n\r\n\r\n",
    "preview": "https://raw.githubusercontent.com/EcoDynIZW/EcoDynIZW.github.io/main/img/wiki/hex-camtrapr.png",
    "last_modified": "2023-10-30T10:34:49+01:00",
    "input_file": {}
  },
  {
    "path": "posts/nlmr/",
    "title": "Simulate Neutral Landscape Models",
    "description": "Learn how to use the {NLMR} R package to simulate neutral landscape models (NLMs), a common set of various null models for spatial analysis and as input for spatially-explicit, generic models.",
    "author": [
      {
        "name": "Cedric Scherer",
        "url": "https://cedricscherer.com"
      }
    ],
    "date": "2021-08-06",
    "categories": [
      "tutorial",
      "rstats",
      "spatial",
      "modelling"
    ],
    "contents": "\r\nThe {NLMR} R package to simulate neutral landscape models (NLM). Designed to be a generic framework like NLMpy, it leverages the ability to simulate the most common NLM that are described in the ecological literature.\r\nIf you want to learn more about the {NLMR} package and the accompanying {landscapetools} package, check the publication Sciaini, Fritsch, Scherer 6 Simpkins (2019) Methods in Ecology and Evolution.\r\nInstallation\r\nInstall the release version from CRAN:\r\n\r\n\r\ninstall.packages(\"NLMR\")\r\n\r\n\r\nor the development version from Github, along with two packages that are needed for the generation of random fields:\r\n\r\n\r\ninstall.packages(\"remotes\")\r\nremotes::install_github(\"cran/RandomFieldsUtils\")\r\nremotes::install_github(\"cran/RandomFields\")\r\nremotes::install_github(\"ropensci/NLMR\")\r\n\r\n\r\nUsage\r\nEach neutral landscape models is simulated with a single function (all starting with nlm_) in NLMR, e.g.:\r\n\r\n\r\nrandom_cluster <- NLMR::nlm_randomcluster(\r\n  nrow = 100,\r\n  ncol = 100,\r\n  p    = 0.5,\r\n  ai   = c(0.3, 0.6, 0.1),\r\n  rescale = FALSE\r\n)\r\n\r\nrandom_curdling <- NLMR::nlm_curds(\r\n  curds = c(0.5, 0.3, 0.6),\r\n  recursion_steps = c(32, 6, 2)\r\n)\r\n\r\nmidpoint_displacement <- NLMR::nlm_mpd(\r\n  ncol = 100,\r\n  nrow = 100,\r\n  roughness = 0.61\r\n)\r\n\r\n\r\n{NLMR} supplies 15 NLM algorithms, with several options to simulate derivatives of them. The algorithms differ from each other in spatial auto-correlation, from no auto-correlation (random NLM) to a constant gradient (planar gradients).\r\nThe package builds on the advantages of the raster package and returns all simulation as RasterLayer objects, thus ensuring a direct compatibility to common GIS tasks and a flexible and simple usage:\r\n\r\n\r\nclass(random_cluster)\r\n\r\n[1] \"RasterLayer\"\r\nattr(,\"package\")\r\n[1] \"raster\"\r\n\r\nrandom_cluster\r\n\r\nclass      : RasterLayer \r\ndimensions : 100, 100, 10000  (nrow, ncol, ncell)\r\nresolution : 1, 1  (x, y)\r\nextent     : 0, 100, 0, 100  (xmin, xmax, ymin, ymax)\r\ncrs        : NA \r\nsource     : memory\r\nnames      : clumps \r\nvalues     : 1, 3  (min, max)\r\n\r\nVisualization\r\nThe {landscapetools} package provides a function show_landscape that was developed to plot raster objects and help users to adhere to some standards concerning color scales and typography. This means for example that by default the viridis color scale is applied (and you can pick others from the {viridis} package, too).\r\n\r\n\r\n#install.packages(\"landscapetools\")\r\n\r\n## plotting continuous values\r\nlandscapetools::show_landscape(random_cluster)\r\n\r\n\r\n## plotting discrete values\r\nlandscapetools::show_landscape(random_curdling, discrete = TRUE)\r\n\r\n\r\n## using another viridis palette\r\nlandscapetools::show_landscape(midpoint_displacement, viridis_scale = \"magma\")\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "https://raw.githubusercontent.com/EcoDynIZW/EcoDynIZW.github.io/main/img/wiki/hex-nlmr.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/d6berlinpackage/",
    "title": "Spatial Datasets and Template Maps for Berlin",
    "description": "Learn how to use the {d6berlin} R package that provides spatial data sets and template maps for Berlin with carefully chosen and aesthetically pleasing defaults. The template maps include Berlin districts, green spaces, imperviousness levels, water bodies, district borders, roads, metro stations, and railways. Templates maps are created with a {ggplot2} wrapper function with the utility to add an inset globe with a locator pin, a scalebar, and a caption stating the data sources.",
    "author": [
      {
        "name": "Cedric Scherer",
        "url": "https://cedricscherer.com"
      }
    ],
    "date": "2021-03-18",
    "categories": [
      "tutorial",
      "rstats",
      "spatial",
      "Berlin",
      "ggplot2",
      "data sources",
      "workflow"
    ],
    "contents": "\r\n\r\nContents\r\nInstallation\r\nA Basic Template Map of Imperviousness\r\nBerlin Data Sets\r\nAdding Locations to the Map\r\nCustom Styling\r\nSave Map\r\n\r\nThe {d6berlin} package aims provide template maps for Berlin with carefully chosen and aesthetically pleasing defaults. Template maps include green spaces, imperviousness levels, water bodies, district borders, roads, and railways, plus the utility to add a globe with locator pin, a scalebar, and a caption to include the data sources.\r\nThere are two main functionalities:\r\nCreate a template map with imperviousness and green spaces with base_map_imp()\r\nProvide various ready-to-use Berlin data sets with sf_*\r\nFurthermore, the package provides utility to add a globe with locator pin, a scalebar, and a caption to include the data sources.\r\nInstallation\r\nYou can install the {d6berlin} package from GitHub:\r\n\r\n\r\n## install.packages(\"remotes\")\r\n## remotes::install_github(\"EcoDynIZW/d6berlin\")\r\nlibrary(d6berlin)\r\n\r\n\r\nNote: If you are asked if you want to update other packages either press ‚ÄúNo‚Äù (option 3) and continue or update the packages before running the install command again.\r\nA Basic Template Map of Imperviousness\r\nThe basic template map shows levels of imperviousness and green areas in Berlin. The imperviousness raster data was derived from Geoportal Berlin (FIS-Broker) with a resolution of 10m. The vector data on green spaces was collected from data provided by the OpenStreetMap Contributors. The green spaces consist of a mixture of land use and natural categories (namely ‚Äúforest‚Äù, ‚Äúgrass‚Äù, ‚Äúmeadow‚Äù, ‚Äúnature_reserve‚Äù, ‚Äúscrub‚Äù, ‚Äúheath‚Äù, ‚Äúbeach‚Äù, ‚Äúcliff‚Äù).\r\nThe map is projected in EPSG 4326 (WGS84).\r\n\r\n\r\nd6berlin::base_map_imp()\r\n\r\n#> Aggregating raster data.\r\n#> Plotting basic map.\r\n#> Styling map.\r\n\r\n\r\nYou can also customize the arguments, e.g.¬†change the color intensity, add a globe with a locator pin, change the resolution of the raster, and move the legend to a custom position:\r\n\r\n\r\nbase_map_imp(color_intensity = 1, globe = TRUE, resolution = 500,\r\n             legend_x = .17, legend_y = .12)\r\n\r\n\r\n\r\nIf you think the legend is not need, there is also an option called \"none\". (The default is \"bottom\". You can also use of the predefined setting \"top\" as illustrated below or a custom position as shown in the previous example.)\r\nBerlin Data Sets\r\nThe package contains several data sets for Berlin. All of them start with sf_, e.g.¬†d6berlin::sf_roads. Here is a full overview of the data sets that are available:\r\n\r\n\r\n\r\nAdding Locations to the Map\r\nLet‚Äôs assume you have recorded some animal locations or you want to plot another information on to of this plot. For example, let‚Äôs visualize the Berlin metro stations by adding geom_sf(data = x) to the template map:\r\n\r\n\r\nlibrary(ggplot2)\r\nlibrary(sf)\r\n\r\nmap <- base_map_imp(color_intensity = .4, resolution = 500, legend = \"top\")\r\n\r\nmap + geom_sf(data = sf_metro) ## sf_metro is contained in the {d6berlin} package\r\n\r\n\r\n\r\nNote: Since the template map contains many filled areas, we recommend to add geometries with variables mapped to color|colour|col to the template maps.\r\nYou can, of course, style the appearance of the points as usual:\r\n\r\n\r\nmap + geom_sf(data = sf_metro, shape = 8, color = \"red\", size = 2)\r\n\r\n\r\n\r\nIt is also possible to filter the data inside the geom_sf function ‚Äî no need to use subset:\r\n\r\n\r\nlibrary(dplyr) ## for filtering\r\nlibrary(stringr) ## for filtering based on name\r\n\r\nmap + \r\n  geom_sf(data = filter(sf_metro, str_detect(name, \"^U\")), \r\n          shape = 21, fill = \"dodgerblue\", size = 2) +\r\n  geom_sf(data = filter(sf_metro, str_detect(name, \"^S\")), \r\n          shape = 21, fill = \"forestgreen\", size = 2)\r\n\r\n\r\n\r\nYou can also use the mapping functionality of ggplot2 to address variables from your data set.\r\n\r\n\r\nmap + \r\n  geom_sf(data = sf_metro, aes(color = type), size = 2) +\r\n  scale_color_discrete(type = c(\"forestgreen\", \"dodgerblue\"), \r\n                       name = NULL) +\r\n  guides(color = guide_legend(direction = \"horizontal\",\r\n                              title.position = \"top\", \r\n                              title.hjust = .5))\r\n\r\n\r\n\r\n(It looks better if you style the legend in the same horizontal layout.)\r\nCustom Styling\r\nSince the output is a ggplot object, you can manipulate the result as you like (but don‚Äôt apply a new theme, this will mess up the legend design):\r\n\r\n\r\nlibrary(systemfonts) ## for title font\r\n\r\nbase_map_imp(color_intensity = 1, resolution = 250, globe = TRUE,\r\n             legend_x = .17, legend_y = .12) + \r\n  geom_sf(data = sf_metro, shape = 21, fill = \"white\", \r\n          stroke = .4, size = 4) +\r\n  ggtitle(\"Metro Stations in Berlin\") + \r\n  theme(plot.title = element_text(size = 30, hjust = .5, family = \"Bangers\"),\r\n        panel.grid.major = element_line(color = \"white\", linewidth = .3),\r\n        axis.text = element_text(color = \"black\", size = 8),\r\n        plot.background = element_rect(fill = \"#fff0de\", color = NA),\r\n        plot.margin = margin(rep(20, 4)))\r\n\r\n\r\n\r\nSave Map\r\nUnfortunately, the size of the text elements is fixed. The best aspect ratio to export the map is 12x9 and you can save it with ggsave() for example:\r\n\r\n\r\nggsave(\"metro_map.pdf\", width = 12, height = 9, device = cairo_pdf)\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "https://raw.githubusercontent.com/EcoDynIZW/EcoDynIZW.github.io/main/img/wiki/hex-d6berlin.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  },
  {
    "path": "posts/d6package/",
    "title": "Simplify Workflows of D6 Research Projects",
    "description": "Learn how to use the {d6} package to follow the project workflow within the department ‚ÄúEcological Dynamics‚Äù at the Leibniz Institute for Zoo and Wildlife Research. The package functionality allows you to set up a standardized folder structure, to use templates for standardized reports and provides some helpful utility functions.",
    "author": [
      {
        "name": "Cedric Scherer",
        "url": "https://cedricscherer.com"
      }
    ],
    "date": "2020-12-09",
    "categories": [
      "tutorial",
      "rstats",
      "workflow",
      "data management"
    ],
    "contents": "\r\n\r\nContents\r\nInstallation\r\nCreate Project Directory\r\nUse A Custom Root Directory\r\nUse Version Control\r\nSetup without Geo Directories\r\nAdd Documentation to Your Project\r\n\r\nInstall Common Packages\r\nUse Custom Rmarkdown Templates\r\nRender Rmarkdown Files to Reports\r\n\r\nThe {d6} package aims to simplify workflows of our D6 research projects by providing a standardized folder structure incl.¬†version control, Rmarkdown templates, and other utilities.\r\nThere are four main functionalities:\r\nCreate standardized project directories with\r\nnew_project()\r\nInstall a set of common packages with\r\ninstall_d6_packages()\r\nProvide custom Rmarkdown templates via\r\nFile > New File > Rmarkdown... > From Template\r\nRender all Rmarkdown documents to ./docs/report with\r\nrender_all_reports() or\r\nrender_report()\r\nInstallation\r\nThe package is not on CRAN and needs to be installed from GitHub. To do\r\nso, open Rstudio and run the following two lines in the console. In case\r\nthe {devtools} package is already installed, skip that step.\r\n\r\n\r\ninstall.packages(\"devtools\")\r\ndevtools::install_github(\"EcoDynIZW/d6\")\r\n\r\n\r\n(Note: If you are asked if you want to update other packages either press ‚ÄúNo‚Äù (option 3) and continue or update the packages before running the install command again.)\r\nCreate Project Directory\r\nRun the function new_project() to create a new project. This will\r\ncreate a standardized directory with all the scaffolding we use for all\r\nprojects in our department. It also add several files needed for\r\ndocumentation of your project.\r\nTo start a new project in the current working directory, simply run:\r\n\r\n\r\nd6::new_project(\"unicornus_wl_sdm_smith_j\")\r\n\r\n\r\nPlease give your project a unique and descriptive name:\r\nspecies_country_topic_name\r\nFor example, when John Smith is developing a species distribution models\r\nfor unicorns in Wonderland, a descriptive title could be:\r\nunicornus_wl_sdm_smith_j. Please use underscores and the\r\ninternational Alpha-2 encoding for\r\ncountries.\r\nThe full scaffolding structure created in the root folder (here\r\nunicornus_wl_sdm_smith_j) is the following:\r\n\r\n. \r\n‚îî‚îÄ‚îÄ unicornus_wl_sdm_smith_j\r\n    ‚îú‚îÄ‚îÄ .Rproj.user         ‚Äî  Rproject files\r\n    ‚îú‚îÄ‚îÄ data-raw            ‚Äî  raw data (tabular data in root folder)\r\n    ‚îÇ    ‚îî‚îÄ‚îÄ geo-raw        ‚Äî  raw spatial data\r\n    ‚îú‚îÄ‚îÄ docs                ‚Äî  documents\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ admin           ‚Äî  adminstrative docs, e.g. permits \r\n    ‚îÇ   ‚îú‚îÄ‚îÄ literature      ‚Äî  literature used for parameterization + ms\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ manuscript      ‚Äî  manuscript drafts (main + supplement)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ presentations   ‚Äî  talks and poster presentations\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ reports         ‚Äî  rendered reports\r\n    ‚îú‚îÄ‚îÄ output              ‚Äî  everything that is computed (except plots)\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ data-proc       ‚Äî  processed tabular data\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ geo-proc        ‚Äî  processed spatial data\r\n    ‚îú‚îÄ‚îÄ plots               ‚Äî  plot output\r\n    ‚îú‚îÄ‚îÄ R                   ‚Äî  scripts\r\n    ‚îÇ   ‚îú‚îÄ‚îÄ 00_start.R      ‚Äî  first script to run\r\n    ‚îÇ   ‚îî‚îÄ‚îÄ XX_submit.R     ‚Äî  final script to run\r\n    ‚îú‚îÄ‚îÄ .gitignore          ‚Äî  contains which files to ignore for version control\r\n    ‚îú‚îÄ‚îÄ .Rbuildignore       ‚Äî  contains which files to ignore for package builds\r\n    ‚îú‚îÄ‚îÄ DESCRIPTION         ‚Äî  contains project details and package dependencies\r\n    ‚îú‚îÄ‚îÄ NAMESPACE           ‚Äî  contains context for R objects\r\n    ‚îî‚îÄ‚îÄ project.Rproj       ‚Äî  Rproject file: use to start your project\r\n\r\nUse A Custom Root Directory\r\nYou do not need to change the working directory first‚Äîyou can also\r\nspecify a path to a custom root folder in which the new project folder\r\nis created:\r\n\r\n\r\n## both work:\r\nd6::new_project(\"unicornus_wl_sdm_smith_j\", path = \"absolute/path/to/the/root/folder\")\r\n## or:\r\nd6::new_project(\"unicornus_wl_sdm_smith_j\", path = \"absolute/path/to/the/root/folder/\")\r\n\r\n\r\nThe resulting final directory of your project would be\r\nabsolute/path/to/the/root/folder/unicornus_wl_sdm_smith_j.\r\nUse Version Control\r\nIf you want to create a GitHub repository for the project at the same\r\ntime, use instead:\r\n\r\n\r\nd6::new_project(\"unicornus_wl_sdm_smith_j\", github = TRUE)\r\n\r\n\r\nBy default, the visibility of the GitHub repository is set to ‚Äúprivate‚Äù\r\nbut you can also change that:\r\n\r\n\r\nd6::new_project(\"unicornus_wl_sdm_smith_j\", github = TRUE, private_repo = FALSE)\r\n\r\n\r\nNote that to create a GitHub repo you will need to have configured your\r\nsystem as explained here.\r\nSetup without Geo Directories\r\nIf your project does not (or will not) contain any spatial data, you can\r\nprevent the creation of the directories geo-raw and geo-proc by\r\nsetting geo to FALSE:\r\n\r\n\r\nd6::new_project(\"unicornus_wl_sdm_smith_j\", geo = FALSE)\r\n\r\n\r\nAdd Documentation to Your Project\r\nAfter you have set up your project directory, open the file 00_start.R\r\nin the R folder. Add the details of your project, fill in the readme,\r\nadd a MIT license (if needed) and add package dependencies.\r\nInstall Common Packages\r\nYou can install the packages that are most commonly used in our\r\ndepartment via install_d6_packages():\r\n\r\n\r\nd6::install_d6_packages()\r\n\r\n\r\nNote that this function is going to check preinstalled versions and will\r\nonly install packages that are not installed with your current R\r\nversion.\r\nAgain, there is an arguement geo so you can decide if you want to\r\ninstall common geodata packages as well (which is the default). If you\r\nare not intending to process geodata, set geo to FALSE:\r\n\r\n\r\nd6::install_d6_packages(geo = FALSE)\r\n\r\n\r\nThe default packages that are going to be installed are:\r\n\r\ntidyverse (tibble, dplyr, tidyr, ggplot2, readr, forecats, stringr, purrr), lubridate, here, vroom, patchwork, usethis\r\n\r\nThe following packages will be installed in case you specify\r\ngeo = TRUE:\r\n\r\nrgdal, geos, raster, sp, sf, tmap\r\n\r\nUse Custom Rmarkdown Templates\r\nThe package also provides several templates for your scripts. In\r\nRstudio, navigate to File > New File > RMarkdown... > Templates and\r\nchoose the template you want to use. All templates come with a\r\npreformatted YAML header and chunks for the setup.\r\nThe following templates are available for now:\r\nEcoDynIZW Basic: Template for a basic Rmarkdown research report\r\nincluding bits of codes and comments to get started\r\nEcoDynIZW Minimal: Template for an Rmarkdown research report\r\n(almost empty)\r\nRender Rmarkdown Files to Reports\r\nThe render_*() functions take care of knitting your Rmarkdown files\r\ninto HTML reports. The functions assume that your .Rmd files are saved\r\nin the R directory or any subdirectory, and will store the resulting\r\n.html files in the according directory, namely ./docs/reports/.\r\nYou can render all .Rmd files that are placed in the R directory and\r\nsubdirectories in one step:\r\n\r\n\r\nd6::render_all_reports()\r\n\r\n\r\nYou can also render single Rmarkdown documents via render_report():\r\n\r\n\r\nd6::render_report(\"my-report.Rmd\")\r\nd6::render_report(\"notsurewhybutIhaveasubfolder/my-report.Rmd\")\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "https://raw.githubusercontent.com/EcoDynIZW/EcoDynIZW.github.io/main/img/wiki/hex-d6.png",
    "last_modified": "2023-10-19T12:55:42+02:00",
    "input_file": {}
  }
]
